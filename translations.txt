en
es

A Logic Calculator
Calculador Lógico

a web application that decides statements in symbolic logic including modal logic, propositional logic and unary predicate logic
Un aplicación web que decide fórmulas en lógica simbólica, incluyendo lógica modal, lógica proposicional, y lógica de predicados unarios

Decide
Decidir

Depict
Diagramar

Truth Table
Tabla de verdad

Example
Ejemplo

Counterexample
Contraejemplo

Tree Proof
Árbol semántico

Quick Reference
Referencia rápida

Cancel
Cancela

Information:
Información:

What is this?
¿Qué es ésto?

Instructions
Instrucciones

The Language
El lenguaje

The Algorithm
El algoritmo

Updates
Versiones Actualizadas (Inglés)

Contact
Contacto

Downloads
Descargas de Software (Inglés)

Examples:
Ejemplos:

list of symbols used by somerby.net/mack/logic
lista de símbolos utilizados por somerby.net/mack/logic

Symbols
Símbolos

therefore
por lo tanto

and
y

or
o

not
no

if &hellip; then &hellip;
si &hellip;, entonces &hellip;

if and only if
si y sólo si

XOR
o bien &hellip; o bien

NOR
ni &hellip; ni

for all x, &hellip;
para todo x, &hellip;

for some x, &hellip;
existe al menos un x, y &hellip;

x is y
x es y

necessarily
necesariamente

possibly
es posible que

necessarily, if &hellip; then &hellip;
es necesario que si &hellip;, entonces &hellip;

P is true
P es cierto

p is true
p es cierto

x is P
x es P

x is P of y
x es P de y

all S are P
todo S es P

no S are P
ningún S es P

some S are P
algún S es P

not all S are P
algún S no es P

either all S are P or no S are P
todo S es P o ningún S es P

some S are P and some S are not P
algún S es P y algún S no es P

 objects are P
 objetos son P

 of P, Q, &hellip; are true
 de P, Q, &hellip; son ciertos

Statements across Lines
Fórmulas en más de una línea

 and 
 y 

 , therefore 
 , por lo tanto 

assert 
afirma 

 AND 
 y 

assert that 
afirma que 

 follows from 
 se sigue de 

 are jointly equivalent to 
 conjuntamente son equivalentes a 

, therefore 
, por lo tanto, 

Can't conjoin an empty list of matrices.
No se puede unir una lista vacía de matrices.

Can't disjoin an empty list of matrices.
No se puede unir una lista vacía de matrices.

{0} of the predicate(s) {1} can't be true because there are only {2} of them.
No es posible que {0} de los predicados {1} sean ciertos porque sólamente hay {2}.

This is a kind of world in which the statement is not true.
Éste es un tipo de mundo en que la fórmula no es cierta.

This is a kind of world in which the statement is true.
Éste es un tipo de mundo en que la fórmula es cierta.

Kind of World
Tipo de mundo

Kinds of Objects:
Tipos de objetos:

Nullary Predicates:
Predicados Nulos:

This is an interpretation of predicates in which the statement is not necessarily true.  <span style="color:red">Red text</span> indicates a kind of world in which the statement is false.  <span style="color:black;font-weight:bold">Black text</span> indicates a kind of world in which the statement is true.
Ésta es una interpretación de los predicados en que la fórmula no es necesariamente cierta.  <span style="color:red">Texto en rojo</span> indica un tipo de mundo en que la fórmula es falsa.  <span style="color:black;font-weight:bold">Texto en negro</span> indica un tipo de mundo en que la fórmula es cierta.

This is an interpretation of predicates in which the statement is possibly true.  <span style="color:red">Red text</span> indicates a kind of world in which the statement is true.  <span style="color:black;font-weight:bold">Black text</span> indicates a kind of world in which the statement is false.
Ésta es una interpretación de los predicados en que la fórmula es posiblemente cierta.  <span style="color:red">Texto en rojo</span> indica un tipo de mundo en que la fórmula es cierta.  <span style="color:black;font-weight:bold">Texto en negro</span> indica un tipo de mundo en que la fórmula es falsa.

Found unmatched parenthesis in "{0}"
Encontró paréntesis sin par en "{0}"

Could not parse "{0}"
No pudo analizar sintácticamente "{0}"

Expected predication or parenthesized expression, found "{0}"
Predicación o expresión entre paréntesis requerida, pero se encontró "{0}"

This proposition can't be evaluated; it contains both individual constants and modal operators.
Esta proposición no puede ser evaluada; contiene constantes individuales y operadores modales.

This proposition can't be decided; it contains both individual constants and modal operators.
Esta proposición no puede ser decidido; contiene constantes individuales y operadores modales.

Can't generate input for Tree Proof Generator from this proposition.
No se puede generar una entrada para Tree Proof Generator a partir de esta proposición.

<Binary Predication<BR/><B><FONT FACE="MONOSPACE">{0}</FONT></B>>
<Predicación binaria<BR/><B><FONT FACE="MONOSPACE">{0}</FONT></B>>

Can't decide a proposition that contains binary predicates.
No puede decidir una proposición que contenga predicados binarios.

<Conjunction<BR/><B><FONT FACE="MONOSPACE">&amp;</FONT></B>>
<Conjunción<BR/><B><FONT FACE="MONOSPACE">&amp;</FONT></B>>

<Disjunction<BR/><B><FONT FACE="MONOSPACE">|</FONT></B>>
<Disyunción<BR/><B><FONT FACE="MONOSPACE">|</FONT></B>>

<Equivalence<BR/><B><FONT FACE="MONOSPACE">&lt;=&gt;</FONT></B>>
<Equivalencia<BR/><B><FONT FACE="MONOSPACE">&lt;=&gt;</FONT></B>>

<Identification<BR/><B><FONT FACE="MONOSPACE">{0}</FONT></B>>
<Identificación<BR/><B><FONT FACE="MONOSPACE">{0}</FONT></B>>

<Joint Denial<BR/><B><FONT FACE="MONOSPACE">!</FONT></B>>
<Disyunción opuesta<BR/><B><FONT FACE="MONOSPACE">!</FONT></B>>

<Necessity<BR/><B><FONT FACE="MONOSPACE">[]</FONT></B>>
<Necesidad<BR/><B><FONT FACE="MONOSPACE">[]</FONT></B>>

<Negation<BR/><B><FONT FACE="MONOSPACE">~</FONT></B>>
<Negación<BR/><B><FONT FACE="MONOSPACE">~</FONT></B>>

<Argument<BR/><B><FONT FACE="MONOSPACE">.\'.</FONT></B>>
<Argumento<BR/><B><FONT FACE="MONOSPACE">.\'.</FONT></B>>

<Null Predicate<BR/><B><FONT FACE="MONOSPACE">{0}</FONT></B>>
<Proposición<BR/><B><FONT FACE="MONOSPACE">{0}</FONT></B>>

<Universal Generalization<BR/><B><FONT FACE="MONOSPACE">{0},</FONT></B>>
<Generalización universal<BR/><B><FONT FACE="MONOSPACE">{0},</FONT></B>>

<Unary Predication<BR/><B><FONT FACE="MONOSPACE">{0}</FONT></B>>
<Predicación unario<BR/><B><FONT FACE="MONOSPACE">{0}</FONT></B>>

Too many predicates!
¡Hay demasiados predicados!

Unhandled subclass of Counterexample encountered in MakeHTML: {0}
Encontró un subclase de Contraejemplo imprevisto en MakeHTML: {0}

This statement is self-contradictory; there are no examples.
Esta fórmula es autocontradictoria; no hay ejemplos.

distinct
distinta

Attempted to construct an invalid KindOfObject: some predicates are both affirmed and denied by the world.
Intentó construir un KindOfObject que no es válido: algunos predicados son afirmados por el mundo y algunos predicados son negados por el mundo.

Attempted to construct an invalid KindOfWorld: some predicates are both affirmed and denied by the object.
Intentó construir un KindOfWorld que no es válido: algunos predicados son afirmados por el objeto y algunos predicados son negados por el objeto.

Invalid replacement directive: {0}
Directiva de reemplazo inválida: {0}

No antecedents found in argument
No se encontraron premisas en el argumento

No consequents found in argument
No se encontraron conclusiones en el argumento

No content found.
No se encontró contenido.

Unhandled form of two-term proposition: {0}
Encontró una forma de proposición de dos términos que es imprevista: {0}

Couldn\'t parse a token from "{0}"
No se pudo generar un token de "{0}"

The argument is valid but its premises are inconsistent.
El argumento es válido pero sus premisas son inconsistentes.

The argument is invalid.
El argumento no es válido.

The argument is valid because its conclusion is tautological.
El argumento es válido porque su conclusión es una tautología.

The argument is valid.
El argumento es válido.

The value Quality.{0} is not supported by this application.
Este aplicación no procesa Quality.{0}.

The statement is necessarily true.
La fórmula es cierta necesariamente.

The statement is contingent.
La fórmula es contingente.

The statement is self-contradictory.
La fórmula es autocontradictoria.

The value Alethicity.{0} is not supported by this application.
Este aplicación no procesa Alethicity.{0}.

JointDenial.TreeProofGeneratorConnector should be unreachable.
JointDenial.TreeProofGeneratorConnector debe ser inalcanzable.

Prover9 does not support modal logic.
Prover9 no es compatible con la lógica modal.

Deciding... {0:n0} of {1:n0} interpretations of predicates tested.
Decidiendo... {0:n0} de {1:n0} interpretaciones de predicados han sido probados.

Null predicate {0}. not found in proposition.
No se encuentra la proposición {0} en la fórmula.

BinaryPredicate compared to non-BinaryPredicate.
BinaryPredicate estaba comparado con un objeto que no es un BinaryPredicate.

No hash code defined for KindOfObject.
No hay un código hash definido para KindOfObject.

UnaryPredicate compared to non-UnaryPredicate.
UnaryPredicate estaba comparado con un objeto que no es un UnaryPredicate.

Attempted to assign a modality to a variable that already had a different modality assigned to it.
Intentó asignar una modalidad a una variable que ya tenía una modalidad diferente asignada.

  Decided in 
  Decidió en 

 seconds.
 segundos.

This statement is necessarily true; there are no counterexamples.
Este fórmula es necesariamente cierta; no hay contraejemplos.

depicting...
diagramando...

No subexpressions found in "{0}".
No encontró subexpresiones en {0}."

<Material Conditional<BR/><B><FONT FACE="MONOSPACE">-&gt;</FONT></B>>
<Condicional material<BR/><B><FONT FACE="MONOSPACE">-&gt;</FONT></B>>

// This is a proposition.\np
// Ésta es una proposición.\np

// This is also a proposition.\nP
// Ésta también es una proposición.\nP

// This means \"p and q are both true.\"\np & q
// Ésta significa \"p y q son ciertos\".\np & q

// This is an argument.\n// \"p & q\" is the premise and \"q\" is the conclusion.\n// \".'.\" means \"therefore\".\n\np & q\n.'.\nq
// Éste es un argumento.\n// \"p & q\" es la premisa y \"q\" es la conclusión.\n// \".'.\" significa \"por lo tanto\".\n\np & q\n.'.\nq

// This is another argument.  Each line\n// above the \"therefore\" symbol is a premise.\n\np\nq\n.'.\nq
// Éste es otro argumento.  Cada línea\n// antes del símbolo de \"por lo tanto\" es una premisa.\n\np\nq\n.'.\nq

// Propositions can be connected with logical operators.\n\np & q // p AND q\n\np | q // p OR q\n\np <=> q // p if and only if q\n\np -> q // if p, then q
// Las proposiciónes se pueden conectar con operadores lógicos.\n\np & q // p y q\n\np | q // p o q\n\np <=> q // p es equivalente a q\n\np -> q // si p, entonces q

// Propositions can be negated.\n\n~p // NOT p
// Las proposiciones pueden ser negadas.\n\n~p // no p

// Propositions can be grouped with parentheses,\n\n((a&b)&c|d<=>(e->f)) -> ~(a|b|c|d)\n\n<=>\n\n// ...but if a statement is long or complicated, it can be\n// broken up across lines.  If a line has an unmatched parenthesis\n// or if it starts or ends with a binary operator, the page will\n// try to connect it to the statements next to it.  The statement\n// above is virtually the same as the statement below:\n\n(\n  (a&b) & c|d\n  <=>\n  (e->f)\n) ->\n~(a|b|c|d)
// Las proposiciones pueden ser agrupadas con paréntesis...\n\n((a&b)&c|d<=>(e->f)) -> ~(a|b|c|d)\n\n<=>\n\n// ...pero si una expresión es larga o compleja, se puede\n// dividir entre líneas.  Si una línea tiene un paréntesis sin pareja\n// o si empece o termina con un operador binario, la página\n// intentará conectarlo con las líneas cercanas.  La expresión\n// anterior es prácticamente la misma que la siguiente:\n\n(\n  (a&b) & c|d\n  <=>\n  (e->f)\n) ->\n~(a|b|c|d)

// This is kind of like an argument, but it goes in both directions.\n\np\nq\n\n<=>\n\nq\np
// Esta es como un argumento, pero va en ambas direcciones.\n\np\nq\n\n<=>\n\nq\np

// This is a predication on one term.\n\nPx // \"x is P.\"\n\n// x is an object and P is a property.
// Ésta es una predicación de un término.\n\nPx // \"x es P.\"\n\n// x es un objeto y P es una propiedad.

// This is predication on two terms.\n\nxRy\n\n// x and y are objects and R is a relation.\n// The \"Decide\" operation doesn't work for statements that contain\n// relations, but the \"Tree Proof\" operation usually does.
// Ésta es una predicación de dos términos.\n\nxRy\n\n// x y y son objetos y R es una relación.\n// La operación \"Decidir\"  o funciona para enunciados que contiene\n// relaciones, pero la operación \"Árbol semántico\" funciona suele.

// This is a universal generalization.\n\nx,Px // \"For all x, Px is true.\"
// Ésta es una generalización universal.\n\nx,Px // \"Para todo x, Px es cierto.\"

// This is an existential quantification.\n\n3x, Px // \"There is an x such that Px is true.\"
// Ésta es una cuantificación existencial.\n\n3x, Px // \"Para al menos un x, Px es cierto.\"

// Variables and Individual Constants\n\nx,Px // This \"x\" is a variable.\n// It is part of a quantification \"for all x, x is P\".\n// It represents many things.\n\nPx // This \"x\" is an individual constant.\n// It is not part of a quantification.\n// It represents just one thing.
// Variables y constantes individuales\n\nx,Px // Este \"x\" es una variable.\n// Es parte de una cuantificación \"para todo x, x es P\".\n// Representa muchas cosas.\n\nPx // Este \"x\" es un constante individual.\n// No es parte de una cuantificación.\n// Representa solo una cosa.

// A Categorial Syllogism\n\n// All men are mortal.\nx,Hx->Mx\n// Socrates is a man.\nHs\n// Therefore,\n.'.\n// Socrates is mortal.\nMs\n\n// This argument is a syllogism, expressed with predicates.\n// It has two premises and one conclusion.\n// It is valid.
// Un silogismo categórico\n\n// Todo hombre es mortal.\nx,Hx->Mx\n// Sócrates es hombre.\nHs\n// Por lo tanto,\n.'.\n// Sócrates es mortal.\nMs\n\n// Este argumento es un silogismo, expresado con predicados.\n// Tiene dos premisas y una conclusión.\n// Es válido.

// Ordering Drinks\n\n// Everyone will order tea or coffee, but not both.\nx, Tx^Cx\n// Either Jay or Kay will order coffee, but not both.\nCj^Ck\n// If Jay orders coffee, Elle will order tea.\nCj->Tl\n// Elle and Kay will not both order tea.\n~(Tl&Tk)\n//Therefore:\n.'.\n// Jay won't order coffee.\n~Cj\n// Kay won't order tea.\n~Tk\n\n// This is a more complicated argument, expressed with predicates.\n// It has four premises and two conclusions.\n// It is valid.
// Ordenando bebidas\n\n// Cada persona pedirá o bien té o bien café.\np, Tp^Cp\n// Pedirá café o bien Xavier or o bien Yolanda.\nCx^Cy\n// Si Xavier pide café, Zacarías pedirá té.\nCx->Tz\n// Zacarías y Yolanda no pedirán ambos té.\n~(Tz&Ty)\n//Por lo tanto:\n.'.\n// Xavier no pedirá café.\n~Cx\n// Yolanda no pedirá té.\n~Ty\n\n// Éste es un argumento más complejo, expresado con predicados.\n// Tiene cuatro premisas y dos conclusiónes.\n// Es válido.

// A Formal Fallacy\n\n// Every person is a ray of sunshine.\nx,Px->Rx\n// Every person is a being of light and shade.\nx,Px->(Lx&Sx)\n// Therefore,\n.'.\n// every being of light and shade is a ray of sunshine.\nx,(Lx&Sx)->Rx\n\n// This is an example of an invalid argument; the conclusion\n// may be false even if the premises are all true.\n// It's attributed to Bertrand Russell.
// Una falacia formal\n\n// Cada persona es un rayo de sol.\nx,Px->Rx\n// Cada persona es un ser de luz y sombra.\nx,Px->(Lx&Sx)\n// Por lo tanto,\n.'.\n// cada ser de luz y sombra es un rayo de sol.\nx,(Lx&Sx)->Rx\n\n// Éste es un ejemplo de un argumento que no es válido; la conclusión\n// puede ser falso incluso si las premisas son todas ciertas.\n// Se le atribuye a Bertrand Russell.

// An Equivalence\n\n// Here, there are two statement on separate lines and\n// a biconditional on a line between them.\n// This effectively means \"Statement 1 is true if and only if\n// Statement 2 is true\".\n\n// \"If any NP-complete problem can be solved in polynomial time,\n// then all NP-complete problems can be solved in\n// polynomial time.\"\n(3x,Nx&Px) -> (x,Nx -> Px)\n\n<=> // is equivalent to\n\n// \"If two problems are NP-complete, then if one is\n// solvable in polynomial time, the other is also solvable in\n// polynomial time.\"\nx,y, (Nx&Ny) -> (Px -> Py)
// Una equivalencia\n\n// Aquí, son dos enunciados en lineas distintas y\n// un biconditional en su línea propia, entres de los dos.\n// Esto significa efectivamente \"Enunciado 1 es cierto si y solo si\n// Enunciado 2 es cierto\".\n\n// \"Si cualquier problema de NP-completo se puede resolver en tiempo\n// polinómico, entonces todos los problemas de NP-completo se pueden resolver\n// en tiempo polinómico.\"\n(3x,Nx&Px) -> (x,Nx -> Px)\n\n<=> // es equivalente a\n\n// \"Si dos problemas son NP-completos, entonces si uno \n// se puede resolver en tiempo polinómico, el otro también se puede\n// resolver en tiempo polinómico.\"\nx,y, (Nx&Ny) -> (Px -> Py)

// A Trivially Valid Argument\n\nLs    // Lois Lane loves Superman.\n~Lc   // Lois Lane does not love Clark Kent.\nc=s   // Clark Kent is Superman.\n\n.'.   // Therefore,\n\n~Ms   // Superman never made any money saving the world from Solomon Grundy.\n\n// This is technically a valid argument, but the premises are inconsistent\n// (they can't all be true), so any conclusion would be valid.
// Ex contradictione quodlibet\n\nAs    // Lois Lane ama a Superman.\n~Ac   // Lois Lane no ama a Clark Kent.\nc=s   // Clark Kent es Superman.\n\n.'.   // por lo tanto,\n\n~Ms   // Superman nunca ganó dinero\n      // salvando el mundo de Solomon Grundy.\n\n// Técnicamente, éste es un argumento válido, pero las premisas son\n// inconsistentes (todos no pueden ser ciertos), entonces\n// cualquier conclusión sería válida.

// Necessity\n\n[]P // P is necessarily true; it is true in all possible worlds.
// Necesidad\n\n[]P // P es cierto necesariamente;\n    // es cierto en todos los mundos posibles.

// Possiblity\n\n<>P // P is possibly true; it is true in at least one possible world.
// Posibilidad\n\n<>P // P es cierto posiblemente;\n    // es cierto en al menos un mundo posible.

// Quantifers inside of Modal Operators\n\n// If a quantifier is inside of a modal operator, the modal operator\n// ranges over possible worlds and the quantifier ranges over the objects\n// within each world.\n\n[](x,A->Px) // \"In each possible world, if A is true that world,\n            // then everything in that world is P.\"
// Cuantificadores dentro de operadores modales\n\n// Si un cuantificador es dentro de un operador modal, el operador modal\n// extiende encima mundos posibles y el cuantificador extiende encima los\n// objetos en cada mundo.\n\n[](x,A->Px) // \"En cada mundo posible, si A es cierto en aquel mundo,\n            // entonces todo de los objectos in aquel mundo son P.\"

// Quantifiers outside of Modal Operators.\n\n// If a quantifier is outside of a modal operator, the modal operator\n// ranges over possible words, but the variable is held constant.\n\nx,[](A->Px) // \"For each thing in _this_ world, for each possible world,\n            // if A is true in that world, then the thing in _this_ world\n            // is P.\"
// Cuantificadores fuera de operadores modales\n\n// Si un cuantificador es afuera de un operador modal, el operador modal\n// extiende encima mundos posibles, pero la variable se mantiene constante.\n\nx,[](A->Px) // \"Para cada cosa en _este_ mundo, para cada mudo possible,\n            // si A es cierto en aquel mundo,\n            // entonces la cosa en _este_ mundo es P.\"

// Axioms of Modal Logic\n\n// Each of the following statements is an axiom of modal logic\n// that is true according to this page's decision algorithm.\n\n// Axiom D\n[]A -> <>A\n\n// Axiom M\n[]A -> A\n\n// Axiom 4\n[]A->[][]A\n\n// Axiom B\nA -> []<>A\n\n// Axiom 5\n<>A -> []<>A\n\n// Axiom []M\n[]([]A -> A)\n\n// Axiom C4\n[][]A -> []A\n\n// Axiom C\n<>[]A -> []<>A\n\n// Axiom K\n[](A->B)->([]A->[]B)\n\n// Axiom T\n[]A -> A
// Axiomas de lógica modal\n\n// Cada del los enunciados siguientes es un axioma de lógica modal\n// que es cierto por el algoritmo de decisión de esta página.\n\n// Axioma D\n[]A -> <>A\n\n// Axioma M\n[]A -> A\n\n// Axioma 4\n[]A->[][]A\n\n// Axioma B\nA -> []<>A\n\n// Axioma 5\n<>A -> []<>A\n\n// Axioma []M\n[]([]A -> A)\n\n// Axioma C4\n[][]A -> []A\n\n// Axioma C\n<>[]A -> []<>A\n\n// Axioma K\n[](A->B)->([]A->[]B)\n\n// Axioma T\n[]A -> A

// Here, but Not Here\n\n// It's possible for something to be here but not here.\n<>3x,Hx&~Hx
// Aquí, pero no aquí\n\n// Es posible que algo esté aquí pero no esté aquí.\n<>3x,Ax&~Ax

// Barbara\n\nSaR // All squares are rectangles.\nRaP // All rectangles are parallelograms.\n.'. // Therefore,\nSaP // All squares are parallelograms.
// Barbara\n\nCaR // Todos los cuadrados son rectángulos.\nRaP // Todos los rectángulos son paralelogramos.\n.'. // Por lo tanto,\nCaP // Todos los cuadrados son paralelogramos.

// Celarent\n\nReT // No rectangles are trapezoids.\nSaT // All squares are rectangles.\n.'.\nSeT // No squares are trapezoids.
// Celarent\n\nReT // Ningún rectángulo es trapecio.\nCaT // Todos los cuadrados son rectángulos.\n.'.\nCeT // Ningún cuadrado es trapecio.

// Darii\n\nSaR // All squares are rhombuses.\nPiS // Some parallelograms are squares.\n.'.\nPiR // Some parallelograms are rhombuses.
// Darii\n\nCaR // Todos los cuadrados son rombos.\nPiC // Algunos paralelogramos son cuadrados.\n.'.\nPiR // Algunos paralelogramos son rombos.

// Ferio\n\nSeT // No squares are trapezoids.\nQiS // Some quadrilaterals are squares.\n.'.\nQoT // Some quadrilaterals are not trapezoids.
// Ferio\n\nCeT // Ningún cuadrados son trapecios.\nRiC // Algunos rectángulos son cuadrados.\n.'.\nRoT // Algunos rectángulos no son trapecios.

// Baroco\n\nSaR // All squares are rectangles.\nPoR // Some parallelograms are not rectangles.\n.'.\nPoS // Some parallelograms are not squares.
// Baroco\n\nCaR // Todos los cuadrados son rectángulos.\nPoR // Algunos paralelogramos no son rectángulos.\n.'.\nPoC // Algunos paralelogramos no son cuadrados.

// Bocardo\n\nRoS // Some rhombuses are not squares.\nRaP // All rhombuses are parallelograms.\n.'.\nPoS // Some parallelograms are not squares.
// Bocardo\n\nRoC // Algunos rombos no son cuadrados.\nRaP // Todos los rombos son paralelogramos.\n.'.\nPoC // Algunos paralelogramos no son cuadrados.

// Barbari\n\nRaP // All rectangles are parallelograms.\nSaR // All squares are rectangles.\n.'.\nSiP // Some squares are parallelograms.
// Barbari\n\nRaP // Todos los rectángulos son paralelogramos.\nCaR // Todos los cuadrados son rectángulos.\n.'.\nCiP // Algunos cuadrados son paralelogramos.

// Celaront\n\nReT // No rectangles are trapezoids.\nSaR // All squares are rectangles.\n.'.\nSoT // Some squares are not trapezoids.
// Celaront\n\nReT // Ningún rectángulos son trapecios.\nCaR // Todos los cuadrados son rectángulos.\n.'.\nCoT // Algunos cuadrados no son trapecios.

// Camestros\n\nRaP // All rectangles are parallelograms.\nTeP // No trapezoids are parallelograms.\n.'.\nToP // Some trapezoids are not rectangles.
// Camestros\n\nRaP // Todos los rectángulos son paralelogramos.\nTeP // Ningún trapecios son paralelogramos.\n.'.\nToP // Algunos trapecios no son rectángulos.

// Felapton\n\nTeP // No trapezoids are parallelograms.\nTaQ // All trapezoids are quadrilaterals.\n.'.\nQoP // Some quadrilaterals are not parallelograms.
// Felapton\n\nTeP // Ningún trapecios son paralelogramos.\nTaC // Todos los trapecios son cuadriláteras.\n.'.\nCoP // Algunos cuadriláteras no son paralelogramos.

// Darapti\n\nSaR // All squares are rectangles.\nSaQ // All squares are quadrilaterals.\n.'.\nQiR // Some quadrilaterals are rectangles.
// Darapti\n\nCaR // Todos los cuadrados son rectángulos.\nCaP // Todos los cuadrados son paralelogramos.\n.'.\nPiR // Algunos paralelogramos son rectángulos.

Enter statements or arguments here.
Ingrese enunciados o argumentos aquí.

Decide if the entry is valid, invalid, necessary, possible, impossible.
Decide si la entrada es válida, inválida, necesaria, posible, imposible.

Depict the logical structure of the entry.
Diagrama la estructura lógica de la entrada.

Build a truth table for the entry.
Construye una tabla de verdad para la entrada.

Cycle through kinds of worlds where the entry is true.
Recorre tipos de mundos donde la entrada es cierta.

Cycle through kinds of worlds where the entry is false.
Recorre tipos de mundos donde la entrada no es cierta.

Try to prove that the entry is valid with a tree proof generator.
Intenta demostrar que la entrada es válida con un árbol semántico.

Cancel the current operation.
Cancele la operación actual.

Cycle through examples of propositional logic.
Recorre ejemplos de lógica proposicional.

Cycle through examples of predicate logic.
Recorre ejemplos de lógica predicativa.

Cycle through examples of modal logic.
Recorre ejemplos de lógica modal.

Cycle through examples of term (Aristotelian) logic.
Recorre ejemplos de lógica Aristotélica.

Meaning
Significado

Equivalent<br/>Statement
Enunciado<br/>equivalente

&larr; next
&larr;

 Propositional Logic
 Lógica proposicional

 Predicate Logic
 Lógica predicativa

 Modal Logic
 Lógica modal

 Term Logic
 Lógica Aristotélica
 
&#8666;Home
&#8666;Inicio