<!DOCTYPE html>
<!--
  somerby.net/mack/logic
  Copyright (C) 2015, 2023 MacKenzie Cumings
 
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-->

<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Información por somerby.net/mack/logic</title>

<link rel="stylesheet" href="../style.css" type="text/css" />

</head>
<body onload="sgnimuc()">

<div id="text_column">

<h3><a href="index.html">&#8666; Inicio</a></h3>

<h1>somerby.net/mack/logic</h1>

<h2 id="introduction">Introducción</h2>

<p>Esta aplicación web (en lo sucesivo denominada "el software" o "la aplicación") decide la validez / satisfacibilidad / inconsistencia de ciertos tipos de expresiones de la lógica simbólica.</p>

<p>El software, en su parte principal, está escrito en C# y traducido a JavaScript con <a href="http://www.saltarelle-compiler.com/" target="_blank">Saltarelle</a>.  El código fuente se encuentra en <a href="https://github.com/mackwai/UnaryPredicateLogic" target="_blank">GitHub</a>.  Se utiliza <a href="https://github.com/mdaines/viz.js/">Viz.js</a> para generar los diagramas.  La función que hace tablas de verdad está adaptada del <a href="https://github.com/mrieppel/TruthTableGenerator" target="_blank">código</a> escrito por Michael Rieppel.</p>

<p>Agradezco a Maximiliano Paesani su ayuda en la traducción de la aplicación web al español.</em></p>

<h2 id="instructions">Instrucciones</h2>

<p>Para usar esta aplicación, escriba una expresión lógica en el cuadro de texto de la página principal. Luego haga clic en el botón "Decidir". Si la expresión es decidible en la aplicación, se mostrará el resultado. De lo contrario, mostrará algún tipo de mensaje explicando cuál es el error. La sección <a href="#the_language">'El lenguaje'</a> especifica cómo escribir expresiones lógicas para la aplicación. Si está buscando ejemplos de expresiones, haga clic en cualquiera de los botones bajo el encabezado titulado "Ejemplos", y la aplicación llenará el cuadro de texto con alguna expresión a decidir.</p>

<p>Si hace clic en el botón "Diagramar", la aplicación mostrará un diagrama que explicita cómo la aplicación interpreta la expresión escrita en el cuadro de texto. El diagrama es una representación gráfica de la estructura de datos que la aplicación está usando efectivamente para decidir la expresión.</p>

<p>Si en el cuadro de texto hay una expresión sintácticamente válida perteneciente a la lógica proposicional, se habilitará el botón "Tabla de verdad". Al hacer clic allí, la aplicación generará la <a href="http://en.wikipedia.org/wiki/Truth_table" target="_blank">tabla de verdad</a> correspondiente.</p>

<p>Al hacer clic en el botón "Ejemplo", la aplicación intentará encontrar un tipo de mundo en el que la expresión sea verdadera. Si tiene éxito, mostrará una descripción de ese tipo de mundo.</p>

<p>El botón "Contraejemplo", inicia la búsqueda de un tipo de mundo que haga falsa la expresión, y si lo encuentra m su descripción.</p>

<p>El botón "árbol semántico" redirigirá la expresión al <a href="http://www.umsu.de/logik/trees" target="_blank">generador de árboles semánticos</a>(Tree Proof Generator) de wo.
Es una aplicación web que usa tablas semánticas (árboles) para verificar la validez de una expresión, y proporciona una prueba si decide que es válida. El botón "árbol semántico" se habilitará siempre que haya una expresión sintácticamente válida en el cuadro de texto que no contenga identificaciones u operadores modales. Si desea evaluar una expresión que contiene predicados binarios (relaciones), use el Generador de árboles semánticos.</p>

<h2 id="the_language">El lenguaje</h2>

<h3>Elementos del lenguaje</h3>

<p>El lenguaje tiene estos elementos:</p>

<ul>
  <li><a href="#language_logical_operators">Operadores lógicos unarios y binarios</a></li>
  <li><a href="#language_variable">Variables</a></li>
  <li><a href="#language_constant">Constantes Individuales</a></li>
  <li>Predicados sobre <a href="#language_unary_predicate">una variable</a> y predicados sobre <a href="#language_nullary_predicate">cero variables</a> (proposiciones)</li>
  <li>Predicados sobre <a href="#language_binary_predicate">dos variables</a> (relaciones)</li>
  <li><a href="#language_grouping">Agrupación</a> mediante paréntesis</li>
  <li><a href="#language_universal_generalization">Generalizaciones universales</a>, <a href="#language_existential_quantification">cuantificaciones existenciales</a> y <a href="#language_definite_description">y descripciones definidas</a></li>
  <li><a href="#language_identity">Identidad</a></li>
  <li><a href="#language_modal_operators">Los operadores modales de necesidad y posibilidad</a></li>
  <li><a href="#language_two_term_propositions">Proposiciones de dos términos</a></li>
  <li><a href="#language_assertions_of_number">Algunas afirmaciones simples sobre números</a></li>
  <li><a href="#text_replacements">Reemplazos de texto</a></li>
  <li><a href="#language_therefore">Un símbolo de "por lo tanto"</a></li>
</ul>

<h4 id="language_logical_operators">Operadores lógicos</h4>

<p>Los operadores lógicos que el software reconoce son:</p>

<table>
  <tr><th>Operador</th><th>Símbolo</th><th>Descripción</th></tr>
  <tr><td>negación</td>             <td><span class="symbolic">~</span></td>        <td>"no" lógico</td></tr>
  <tr><td>conjunción</td>          <td><span class="symbolic">&amp;</span></td>    <td>"y" lógico</td></tr>
  <tr><td>disyunción</td>          <td><span class="symbolic">|</span></td>        <td>"o" lógico</td></tr>
  <tr><td>condicional material</td> <td><span class="symbolic">-&gt;</span></td>    <td>Si &hellip; entonces &hellip;</td></tr>
  <tr><td>bicondicional</td>        <td><span class="symbolic">&lt;=&gt;</span></td><td>Equivalencia lógica</td></tr>
  <tr><td>negación conjunta</td>         <td><span class="symbolic">!</span></td>        <td>"nor" lógico</td></tr>
  <tr><td>disyunción excluyente</td><td><span class="symbolic">^</span></td>        <td>"Xor" lógico</td></tr>
  <tr><td>implicación estricta</td><td><span class="symbolic">-&lt;</span></td>        <td>necesariamente si &hellip; entonces &hellip;</td></tr>
</table>

<p>Todos los operadores lógicos binarios son asociativos por la izquierda y tienen las siguientes precedencias:</p>

<table>
  <tr><th>Precedencia</th><th>Operadores</th></tr>
  <tr><td>superior</td>  <td><span class="symbolic">&amp;</span>, <span class="symbolic">!</span></td></tr>
  <tr><td>&hellip;</td> <td><span class="symbolic">|</span></td></tr>
  <tr><td>&hellip;</td> <td><span class="symbolic">-&gt;</span>, <span class="symbolic">-&lt;</span></td></tr>
  <tr><td>inferior</td>   <td><span class="symbolic">&lt;=&gt;</span>, <span class="symbolic">^</span></td></tr>
</table>

<p>Por ejemplo,</p>

<pre class="symbolic">A|B&amp;C-&gt;D</pre>

<p>se interpreta como significando lo mismo que</p>

<pre class="symbolic">(A|(B&amp;C))-&gt;D</pre>

<p>La negación es asociativa por derecha y precede a cualquier operador binario, por ello</p>

<pre class="symbolic">~P &amp; ~Q</pre>

<p>se interpreta como significando lo mismo que</p>

<pre class="symbolic">(~P) &amp; (~Q)</pre>

<h4 id="language_variable">Variables</h4>
<p>Las variables son letras minúsculas únicas que representan algún objeto. Cada variable está ligada por un cuantificador. Cualquier letra minúscula que no esté ligada por un cuantificador se interpretará como una <a href="#language_constant">constante individual</a>.</p>

<h4 id="language_constant">Constantes individuales</h4>
<p>Las constantes individuales, como las <a href="#language_variable">variables</a>, son letras minúsculas únicas. Representan algún objeto fijo. Cualquier letra minúscula que no esté limitada por un cuantificador se interpretará como una constante individual. Creo que las constantes no son completamente necesarias en la lógica simbólica. El siguiente argumento:</p>

<pre class="symbolic">Hx-&gt;Mx // Todo hombre es mortal.
Hs     // Socrates es hombre.
-&gt;     // Por lo tanto
Ms     // Socrates es mortal.</pre>

<p class="continuation">podría también representarse sin constantes individuales como</p>

<pre class="symbolic">Hx-&gt;Mx                                   // Todo hombre es mortal.
(3x,Sx) &amp; ([]x,Sx-&gt;y,Sy-&gt;x=y) &amp; x,Sx->Hx // Socrates es hombre.
-&gt;                                       // Por lo tanto
x,Sx->Mx                                 // Socrates es mortal.</pre>

<p class="continuation">lo cual, aunque más complicado, es en cierto modo mejor, porque hace explícito lo que típicamente suponemos acerca de Sócrates: que existió y que era, por definición, un individuo único.
Aun así, creo que las constantes individuales son una característica demasiado útil para excluirlas del software.
El uso de una constante individual implica que el objeto denotado por ella realmente existe.
Esta no es la única forma de interpretar constantes individuales, pero es la más fácil de implementar en este software.
Debido a esta interpretación, el software decidirá que <span class="symbolic">3x,x=g</span> es necesariamente cierto.
Los objetos posibles (aquellos que pueden o no existir) y los objetos imposibles (los que nunca podrían existir) se pueden representar con predicados unarios.</p>

<p>Como todavía no he encontrado una manera satisfactoria de <a href="#decide">decidir</a> expresiones que contienen tanto operadores modales como constantes individuales, el software rechaza cualquier expresión de este tipo.</p>

<h4 id="language_nullary_predicate">Predicados sobre cero variables</h4>

<p>Un predicado de cero variables, que se puede considerar como una proposición verdadero/falso, se representa con una sola letra.</p>

<h4 id="language_unary_predicate">Predicados en una variable</h4>

<p>Una predicación sobre una variable, que puede considerarse como la afirmación de que un objeto tiene alguna propiedad, se representa con una sola letra mayúscula (el predicado) seguida de una sola letra minúscula (la variable). Se puede usar la misma letra mayúscula como predicado sobre una variable y como predicado sobre cero variables en la misma expresión y el software las tratará como predicados distintos, por ejemplo</p>

<pre class="symbolic">x,Fx-&gt;F</pre>

<p class="continuation">será interpretado de la misma manera que</p>

<pre class="symbolic">x,Fx-&gt;P</pre>

<p class="continuation">porque la primera &quot;<span class="symbolic">F</span>&quot; se interpreta como un predicado unario y la segunda &quot;<span class="symbolic">F</span>&quot; se interpreta como un predicado nulo.</p>

<h4 id="language_binary_predicate">Predicados en dos variables</h4>

<p>Una predicación sobre dos variables, que puede considerarse como la afirmación de que dos objetos tienen alguna relación entre sí, se representa con una sola letra mayúscula (el predicado) seguida de dos letras minúsculas (las variables). El algoritmo de decisión no admite predicados sobre dos variables y, por lo general, rechazará una expresión que las contenga. Sin embargo, las expresiones que tienen predicados en dos variables pueden evaluarse con el Generador de árboles semánticos, si no contienen también <a href="#language_modal_operators">operadores modales</a> o <a href="#language_identity">identificaciones</a>.</p>

<h4 id="grouping">Agrupación</h4>

<p>Las expresiones se pueden agrupar con paréntesis. Funcionan igual que los paréntesis en álgebra o en otras lógicas simbólicas.</p>

<h4 id="language_universal_generalization">Generalizaciones universales</h4>

<p>Una generalización universal es una variable seguida de una coma y seguida de la expresión a la que se aplica la generalización. De acuerdo con esto, se podría escribir

<pre class="symbolic">x,Ax</pre>

<p class="continuation">para decir "todo es asombroso". La generalización liga toda la expresión que sigue a la coma, hasta un paréntesis de cierre o el final de la línea de texto en la que se encuentra la generalización. Así</p>

<pre class="symbolic">x,Fx &amp; y,Jy</pre>

<p class="continuation">generaliza sobre la sub-expresión</p>

<pre class="symbolic">Fx &amp; y,Jy</pre>

<p class="continuation">en vez de ser sólo una generalización sobre <span class="symbolic">Fx</span>.  Se recomienda añadir paréntesis a los fines de mayor claridad. Por ejemplo:</p>

<pre class="symbolic">(x, Fx &amp; (y,Jy))</pre>

<p>Una variable siempre está ligada a la generalización delimitante más próxima, por ello en</p>

<pre class="symbolic">x, (x,F-&gt;Px) &amp; Jx</pre>

<p class="continuation">la <span class="symbolic">x</span> en <span class="symbolic">Px</span> está ligada por la segunda generalización universal y la x en Jx está ligada por la primera.</p>

<h4 id="language_existential_quantification">Cuantificación existencial</h4>

<p>Una cuantificación existencial es un símbolo "<span class="symbolic">3</span>" seguido de una variable, seguida de una coma y, finalmente, seguida de una expresión a la cual se aplica la cuantificación. Por ejemplo,</p>

<pre class="symbolic">3x, Fx &amp; Bx</pre>

<p class="continuation">podría significar "Hay una fuente llena de sangre". Las mismas reglas de aplicabilidad y ligación de variables definidas para las generalizaciones universales se aplican también a las cuantificaciones existenciales.</p>

<h4 id="language_definite_description">Descripciones definidas</h4>

<p>Una descripción definida es un "<span class="symbolic">1</span>" seguido de una variable, seguida de una coma, seguida de una expresión que, se supone, describe exactamente un objeto. Por ejemplo,</p>

<pre class="symbolic">1x,Rx</pre>

<p class="continuation">podría significar "existe sólo un Roy Orbison".</p>

<h4 id="language_identity">Identidad</h4>

<p>Una identidad entre dos objetos consiste en una letra minúscula seguida de un signo igual seguido de otra letra minúscula, por ejemplo</p>

<pre class="symbolic">x,y, (Fx &amp; x=y) -&gt; Fy</pre>

<p class="continuation">es una afirmación donde "<span class="symbolic">x=y</span>" significa <span class="symbolic">x</span> es el mismo objeto que <span class="symbolic">y</span>.</p>

<h4 id="language_modal_operators">Operadores modales</h4>

<p>El software reconoce dos operadores modales, "<span class="symbolic">[]</span>" para necesidad y "<span class="symbolic">&lt;&gt;</span>" para posibilidad.  Son asociativos por la derecha y tienen la misma precedencia que la negación. El tipo de modalidad representada por estos operadores es la modalidad <a href="http://en.wikipedia.org/wiki/Alethic_modality">alética</a>.</p>

<h4 id="language_two_term_propositions">Proposiciones de dos términos</h4>

<p>El software reconoce proposiciones de dos términos en lo que se suele denominarse <a href="http://en.wikipedia.org/wiki/Term_logic" target="_blank">lógica "de términos", "aristotélica" o "tradicional"</a>.  Trata las proposiciones de dos términos como enunciados abreviados de la lógica de predicados unarios. Son una letra mayúscula que representa el término del sujeto, seguida de una letra minúscula que representa la forma de la proposición, seguida de una letra mayúscula que representa el término predicado.</p>

<table>
  <tr><th>Símbolo</th><th>Proposición</th><th>Definición</th></tr>
  <tr><td><span class="symbolic">SaP</span></td><td>Todo S es P</td>                      <td><span class="symbolic">(x,Sx-&gt;Px)&amp;(3x,Sx)</span></td></tr>
  <tr><td><span class="symbolic">SeP</span></td><td>Ningún S es P</td>                       <td><span class="symbolic">x,Sx-&gt;~Px</span></td></tr>
  <tr><td><span class="symbolic">SiP</span></td><td>Algún S es P</td>                      <td><span class="symbolic">3x,Sx&amp;Px</span></td></tr>
  <tr><td><span class="symbolic">SoP</span></td><td>No todo S es P</td>                  <td><span class="symbolic">(3x,Sx&amp;~Px)|(~3x,Sx)</span></td></tr>
  <tr><td><span class="symbolic">SuP</span></td><td>O bien Todo S es P o Ningún S es P</td><td><span class="symbolic">(x,Sx-&gt;Px)|(x,Sx-&gt;~Px)</span></td></tr>
  <tr><td><span class="symbolic">SyP</span></td><td>Algún S es P y Algún S no es P</td><td><span class="symbolic">(3x,Sx&amp;Px)&amp;(3x,Sx&amp;~Px)</span></td></tr>
</table>

<p>Para hacer que el tradicional <a href="https://es.wikipedia.org/wiki/Cuadro_de_oposici%C3%B3n_de_los_juicios" target="_blank">Cuadro de oposición</a> sea verdadero, las proposiciones de tipo A se definen con significado existencial y las proposiciones de tipo O se definen sin significado existencial, siguiendo los argumentos de <a href="http://plato.stanford.edu/entries/square/" target="_blank">Terence Parsons</a>.  También reconoce la forma de U y la forma de Y del <a href="http://en.wikipedia.org/wiki/Logical_hexagon">Hexágono de Oposición</a>.</p>

<p>Cualquiera de los términos en una proposición se pueden negar agregando el símbolo "<span class="symbolic">~</span>" por ejemplo, "<span class="symbolic">~Aa~B</span>" se interpretará como "todo no A es no B". Un "<span class="symbolic">~</span>" al principio de la expresión se adjunta al primer término y no a la expresión completa, por lo que "<span class="symbolic">~Aa~B</span>" no se interpreta como "<span class="symbolic">~(Aa~B)</span>" sino como "<span class="symbolic">(~Aa~B)</span>".</p>

<h4 id="language_assertions_of_number">Aserciones numéricas</h4>

<p>El lenguaje incluye un medio para hacer algunas afirmaciones simples de número. Los agregué al idioma solo por conveniencia; a veces ayudan a codificar la lógica en ciertos acertijos lógicos. No pertenecen a ninguna lógica simbólica que yo sepa.</p>

<p>Un número entero no negativo <em>n</em> seguido de una sola letra mayúscula <em>P</em> es una afirmación de que exactamente <em>n</em> objetos tienen la propiedad <em>P</em> .</p>

<p>Un número entero no negativo <em>n</em> seguido de más de una letra mayúscula <em>P, Q, &hellip;</em> es una afirmación de que exactamente <em>n</em> de las proposiciones <em> P, Q, &hellip;</em> son verdaderas.</p>

<table>
  <tr><th>Ejemplo</th><th>Significación</th></tr>
  <tr><td><span class="symbolic">0P</span></td><td>Ningún objeto es P</td></tr>
  <tr><td><span class="symbolic">1P</span></td><td>Exactamente 1 objeto es P</td></tr>
  <tr><td><span class="symbolic">2P</span></td><td>Exactamente 2 objetos son P</td></tr>
  <tr><td><span class="symbolic">0PQR</span></td><td>Ninguna de P, Q y R son ciertas</td></tr>
  <tr><td><span class="symbolic">1PQR</span></td><td>Solo uno de P, Q y R es cierta</td></tr>
  <tr><td><span class="symbolic">2PQR</span></td><td>Exactamente 2 de P, Q y R son ciertas</td></tr>
</table>

<h4 id="text_replacements">Reemplazos de texto</h4>

<p>Una línea que comienza con "<span class="symbolic">#replace</span>" se interpretará como una directiva para reemplazar una cadena de letras o símbolos con otra en las líneas debajo de la directiva. Es una forma de definir sus propios símbolos de operador o dar nombres significativos a predicados y variables. Por ejemplo, cuando se le da el texto</p>

<pre class="symbolic">#replace => ->
#replace hombre H
#replace mortal M
#replace socrates s
#replace porlotanto .'.

x, hombre x => mortal x
hombre socrates
porlotanto
mortal socrates</pre>

<p class="continuation">la aplicación lo convertirá en</p>

<pre class="symbolic">
x, H x -> M x
M s
.'.
M s</pre>

<p class="continuation">antes de analizarlo sintácticamente.</p>

<h4 id="language_therefore">El símbolo "Por lo tanto"</h4>

<p>El símbolo "por lo tanto", "<span class="simbólico">.'.</span>" (punto, apóstrofe, punto) se puede utilizar para probar argumentos lógicos. Se evaluará de la misma manera que el <a href="#material_conditional">material condicional</a>, pero el resultado mostrado será diferente. En lugar de indicar si el argumento es necesariamente cierto, contingente o imposible, el software indicará si el argumento es válido (necesariamente cierto) o inválido (no necesariamente cierto). Además, si el argumento es válido, el software indicará si las premisas son inconsistentes o la conclusión es tautológica.</p>

<h3>Expresiones válidas</h3>

<p>En este idioma, una expresión válida es solo una declaración de verdadero/falso. Puede ser una sola línea, como</p>

<pre class="symbolic">P&amp;Q-&gt;R</pre>

<p class="continuation">o pueden ser varias líneas, como</p>

<pre class="symbolic">Hx-&gt;Mx
Hs
-&gt;
Ms</pre>

<p>Si es una sola línea, el software interpreta la línea como una afirmación y decide si es válida, consistente o contradictoria. Si son varias líneas, el software une estas líneas para formar una sola expresión y decide esta declaración. El software trata cada línea que es una declaración como si estuviera unida a las otras líneas que son declaraciones con un AND lógico. Esto le permite distribuir una declaración larga en varias líneas. Por ejemplo,</p>

<pre class="symbolic">P-&gt;Q
Q-&gt;R
P</pre>

<p class="continuation">se interpreta que significa lo mismo que</p>

<pre class="symbolic">(P-&gt;Q)&amp;(Q-&gt;R)&amp;P</pre>

<p>Si una expresión tiene varias líneas y exactamente una de ellas es un solo operador lógico binario o el símbolo "por lo tanto", el software unirá las líneas antes del operador con un "y" lógico, unirá las líneas después del operador con un "y" lógico y luego une estos dos conjuntos con el único operador lógico. Por ejemplo,</p>

<pre class="symbolic">Hx-&gt;Mx
Hs
-&gt;
Ms</pre>

<p class="continuation">se interpreta que significa lo mismo que</p>

<pre class="symbolic">( (Hx-&gt;Mx) &amp; Hs ) -&gt; (Ms)</pre>

<p>Esto le permite expresar un argumento lógico (varias premisas seguidas de una conclusión) de una manera familiar, o probar si un conjunto de declaraciones es equivalente a otro conjunto de declaraciones sin ponerlas todas en una sola línea.</p>

<p>Las declaraciones largas se pueden dividir en varias líneas. El software interpretará el texto en varias líneas como una declaración de acuerdo con las siguientes reglas:</p>
<ul>
  <li>Si una línea comienza entre paréntesis de apertura y cierre, se unirá con la línea anterior.</li>
  <li>Si una línea termina con un operador binario, se unirá a la línea siguiente.</li>
  <li>Si una línea comienza con un operador binario, se unirá con la línea anterior.</li>
<p>Por ejemplo, los siguientes bloques de texto se interpretan todos de la misma manera:</p>

<ul>
  <li><pre class="symbolic">x,Ax|Bx|Cx</pre></li>
  <li><pre class="symbolic">x,Ax
|Bx
|Cx</pre></li>
<li><pre class="symbolic">x,Ax|
Bx|
Cx</pre></li>
  <li><pre class="symbolic">(x,
Ax|Bx|Cx)</pre></li>
</ul>

<h4>El espacio en blanco</h4>

<p>Los tabuladores, los espacios y las líneas vacías siempre se ignoran. Podrías escribir esto:</p>

<pre class="symbolic">((A   |B|C)-&gt;J )&lt;=&gt;x,F    x&amp;             y,Ix</pre>

<p>o esto:</p>

<pre class="symbolic">(  (A | B |C      )-&gt;J)&lt;=&gt;         x  ,Fx&amp;y,I     x</pre>

<p class="continuation">y esperar el mismo resultado. Los espacios en blanco se pueden utilizar para facilitar la lectura de las expresiones. Pero probablemente querría escribir esto en su lugar:</p>

<pre class="symbolic">((A|B|C) -&gt; J ) &lt;=&gt; x, Fx &amp; y,Ix</pre>

<p class="continuation">porque es más fácil de leer.</p>

<h3>Comentarios</h3>

<p>El software ignora un "<span class="symbolic">//</span>" y todo lo que le sigue en una línea. Esto le permite agregar comentarios útiles a las expresiones, como</p>

<pre class="symbolic">Hx-&gt;Mx // Todos los humanos son mortales.
Hs     // Sócrates es humano.
.'.    // Por lo tanto,
Ms     // Sócrates es mortal.</pre>

<h3>Criterios para el diseño del lenguaje</h3>

<p>El lenguaje que utiliza esta aplicación es una especie de lógica simbólica. Fue diseñado con estos criterios en mente:</p>

<ul>
  <li>El idioma solo debe usar caracteres ASCII básicos que están disponibles en un teclado estándar en inglés, por lo que es fácil para un usuario escribir expresiones.</li>
  <li>Las construcciones del lenguaje deben estar hechas de pocos caracteres para que puedan escribirse rápidamente.</li>
  <li>El lenguaje debe permitir que una persona organice la declaración de tal manera que sea fácil de leer.</li>
  <li>Los símbolos definidos en el idioma deben tener un precedente en otros idiomas. Los símbolos de este lenguaje se toman prestados de la lógica simbólica convencional, la notación matemática convencional y el lenguaje de programación C.</li>
</ul>

<h2 id="the_algorithm">El algoritmo</h2>

<p>Cuando el software <a href="#decide">decide</a> una proposición, no opera sobre sentencias simbólicas. Opera en una estructura de datos similar a un <a href="http://en.wikipedia.org/wiki/Tree_%28data_structure%29">árbol</a> que la estructura lógica de la proposición. En este "árbol", cada nodo es un elemento de la proposición (un predicado, una variable, un cuantificador, etc.) y cada arista es una dependencia entre un elemento y sus elementos subordinados (por ejemplo, un AND lógico es un nodo con bordes que apuntan a los dos elementos a cada lado de la misma).</p>

<h3 id="parsing">Analizando sintácticamente</h3>

<p>El primer paso que toma el software es leer el texto que se le da e intentar convertirlo en un "árbol". Si tiene éxito, el texto es una declaración bien formada dentro del lenguaje simbólico del software y el software puede <a href="#decide">decidir</a> el árbol. Hay más de una forma en que se puede realizar este análisis, por lo que los detalles no son importantes, siempre que el árbol resultante sea correcto.</p>

<p>La elección exacta del idioma tampoco es importante para el proceso de decisión. Siempre que un lenguaje solo represente elementos lógicos que son compatibles con el software y el lenguaje no permita que ningún elemento lógico dependa de sí mismo, directa o indirectamente (por ejemplo, sin la Paradojas de Mentiroso), este lenguaje podría reemplazar el lenguaje reconocido por este. el software y el algoritmo de decisión funcionarían de la misma manera.</p>

<p id="replacement">Para algunos elementos que se pueden definir en términos de otros elementos, el software realiza sustituciones:</p>

<table id="substitutions">
  <caption>Sustituciones</caption>
  <tr><th></th><th>Elemento</th><th>Reemplazo</th></tr>
  <tr><td><span class="symbolic">3x,...</span></td><td>cuantificador existencial</td><td><span class="symbolic">(~x,~...)</span></td></tr>
  <tr><td><span class="symbolic">1x,...</span></td><td>descripción definitiva</td><td><span class="symbolic">(3y,x, x=y &lt;=&gt; ...)</span></td></tr>
  <tr><td><span class="symbolic">&lt;&gt;...</span></td><td>posibilidad</td><td><span class="symbolic">(~[]~...)</span></td></tr>
  <tr><td><span class="symbolic">...^...</span></td><td>disyunción exclusiva</td><td><span class="symbolic">~(...&lt;=&gt;...)</span></td></tr>
</table>

<p>Podría ser útil mostrar algunas declaraciones simbólicas y cómo se ven sus árboles correspondientes. Para la declaración <span class="symbolic">w,Xw-&gt;Tw</span>, que podría interpretarse como "todos mis ex viven en Texas", el software crea un árbol como este:</p>

<img src="../ExesInTexas.png" alt="graph of 'All my exes live in Texas.'" />

<p>Los elementos de la declaración están todos aquí: una generalización universal, una implicación material debajo de ella y dos predicaciones debajo de esto. El conjunto declara una relación lógica entre ser ex de George Strait y vivir en Texas.</p>

<p>Las declaraciones más complicadas tienen árboles más complicados. Para el silogismo</p>

<pre class="symbolic">Hx-&gt;Mx // Todos los humanos son mortales.
Hs     // Sócrates es humano.
.'.    // Por lo tanto,
Ms     // Sócrates es mortal.</pre>

<p class="continuation">el software crea este árbol:</p>

<img src="../Socrates.png" alt="graph of a syllogism" />

<p>El argumento se ha convertido en una sola proposición; el software decidirá si el argumento es válido o no al decidir si esta proposición es cierta necesariamente o no.</p>

<h3 id="decision">Decisión</h3>

<p>El software opera en árboles como los descritos anteriormente. Para decidir una proposición, para cada <a href="#kind_of_world">tipo de mundo</a>, y a veces para cada tipo de mundo en cada <a href="#interpretation">interpretación</a>, el software determina si la proposición representada por el árbol es cierta o equivocada. Si se encuentra que es cierta en cada tipo de mundo, se decide que es necesaria. Si se encuentra que es equivocada en cada tipo de mundo, se decide que es imposible. Si se encuentra que es cierta en algún tipo de mundo y equivocada en otro, se decide que es contingente. El software funciona de arriba hacia abajo. Cada nodo en el árbol es <a href="#evaluate">evaluado</a> por evaluando sus nodos subordinados; ellos a su vez son evaluados por evaluando sus nodos subordinados. El procedimiento para evaluar un nodo depende de qué tipo de elemento lógico representa; cada elemento lógico tiene su propio procedimiento. Las siguientes secciones definen los procedimientos seguidos para cada elemento lógico.</p>

<p>Si la proposición no contiene ninguna <a href="#modality">modalidad</a> o constante individual, la proposición se decide evaluando el árbol para cada tipo de mundo. Esto prueba efectivamente la proposición en todos los <a href="#possible_world">mundos posibles</a> y, por lo tanto, es suficiente para decidir si la proposición es necesariamente verdadera, contingente o imposible.</p>

<p>Si la proposición contiene constantes individuales, la proposición se decide decidiendo otras dos proposiciones. La primera proposición se forma ligando todas las constantes individuales de la proposición original con generalizaciones universales. Si esta proposición es cierta, entonces la proposición original es necesariamente cierta. La segunda proposición se forma vinculando todas las constantes de la proposición original con cuantificadores existenciales. Si esta proposición es imposible, entonces la proposición original es imposible. En todos los demás casos, la proposición original es contingente.</p>

<p>Si la proposición contiene modalidades (posibilidad, necesidad), la proposición no puede decidirse simplemente evaluándola por todo tipo de mundo. Si se hiciera esto, tendría el efecto de tratar cada <a href="#nullary_predicate">predicado nulo</a> como si fuera una proposición contingente, y cada tipo de objeto como un tipo de objeto contingente. Tendría el efecto de hacer que el software decidiera modalidades de manera inesperada. Por ejemplo, el software decidiría que <span class="symbolic">[]P-&gt;~P</span> es necesariamente cierto, ya que aquí se asumiría <span class="symbolic">P</span> ser siempre una proposición contingente y, por lo tanto, nunca necesariamente cierta. En cambio, el software evalúa la proposición bajo cada interpretación. Si es cierta para todo tipo de mundo bajo cada <a href="#interpretation">interpretación</a>, entonces la proposición es necesariamente cierta.</p>


<h4 id="universal_generalization">Evaluación de una generalización universal</h4>

<p>La manera obvia de <a href="#evaluate">evaluar</a> una generalización universal es instanciar su variable con cada objeto en el mundo y <a href="#evaluate">evaluar</a> cada uno de los proposiciones resultantes; si todas las instanciación son ciertas, la generalización es cierta; si alguna es falsa, la generalización es falsa. El problema con este enfoque es que un mundo puede tener una cantidad infinita de objetos, por lo que la evaluación en una cantidad de tiempo finita puede no ser posible. El software no intenta hacer esto. Se necesita un enfoque diferente, pero similar.</p>

<p>Supongamos que todos los objetos de un mundo se pueden agrupar en un número finito de tipos. Supongamos además que estos tipos se definen de tal manera que, si se instancia una generalización universal con cualquier objeto de un tipo, la proposición resultante es lógicamente equivalente a la proposición que resultaría de una instanciación con cualquier otro objeto del mismo tipo. Si todo esto es cierto, entonces la universalización es <a href="#decide">decidible</a>. Y todo esto <em>es</em> cierto. Los elementos lógicos admitidos por el software permiten que los mundos posibles se agrupen de esta manera (la forma en que se realiza esta agrupación se define <a href="#kind_of_object">en otro lugar</a>). Para evaluar una generalización universal, el software instancia la generalización universal con cada <a href="#kind_of_object">tipo de objeto</a> hasta que se hayan probado todos los tipos de objetos o hasta que se encuentre que una instancia es falsa. Si todas las instancias son ciertas, la generalización universal es cierta, si alguna instancia es falsa, la generalización universal es falsa.</p>

<h4>Evaluación de una conjunción ("y" lógico)</h4>

<p>Para evaluar una conjunción, el software evalúa las proposiciones conjuntas. Si ambos son ciertas, la conjunción es cierta. Si alguna es falsa, la conjunción es falsa.)</p>

<h4>Evaluación de una disyunción ("o" lógico)</h4>

<p>Para evaluar una disyunción, el software evalúa las proposiciones separadas. Si ambas son falsas, la disyunción es falsa. Si una o otra de las dos es cierta, la disyunción es cierta.</p>

<h4>Evaluación de una negación ("no" lógico)</h4>

<p>Para evaluar una negación, el software evalúa la proposición negada. Si es cierta, la negación es falsa. Si es falsa, la negación es cierta.</p>

<h4 id="material_conditional">Evaluación de un condicional material</h4>

<p>Para evaluar un condicional material, el software evalúa su antecedente y su consecuente. Si el antecedente es cierta y el consecuente falso, entonces el condicional material es falso. En todos los demás casos, el condicional material es cierta.</p>

<h4>Evaluación de una equivalencia</h4>

<p>Para evaluar una equivalencia, el software evalúa ambos lados de la equivalencia. Si tienen el mismo valor de verdad, la equivalencia es cierta. Si tienen diferentes valores de verdad, la equivalencia es falsa.</p>

<h4>Evaluación de una negación conjunta</h4>

<p>Para evaluar una denegación conjunta, el software evalúa las proposiciones denegadas. Si ambas son falsas, la negación conjunta es cierta. Si cualquiera de las dos es cierta, la negación conjunta es falsa.</p>

<h4>Evaluación de otros elementos lógicos</h4>

<p>El software <a href="#replacement">reemplaza</a> todos los demás elementos lógicos admitidos por el lenguaje con combinaciones equivalentes de elementos, por lo que no necesita procesos adicionales para evaluarlos.</p>

<h4 id="evaluation_of_a_necessity">Evaluación de una necesidad</h4>

<p>Si una proposición es necesariamente cierta, se determina evaluando la proposición en cada <a href="#kind_of_world">tipo de mundo</a> que es posible bajo la <a href="#interpretation">interpretación</ actual. a> de los predicados en la proposición. Si es cierta para todos estos <a href="#kind_of_world">tipos de mundos</a>, entonces es necesariamente cierta. Si es falsa en tal tipo de mundo, no es necesariamente cierta. Prueba: Si la proposición es cierta en todos los <a href="#kind_of_world">tipos de mundos</a>, entonces es cierta en todos los <a href="#possible_world">mundos posibles</a>, y por lo tanto necesariamente cierta. Si la proposición es falsa en cualquier <a href="#kind_of_world">tipo de mundo</a>, entonces es falsa en algún <a href="#possible_world">mundo posible</a>, y por lo tanto no necesariamente cierta.</p>

<h4>Evaluación de una predicación sobre una variable</h4>

<p>Cada vez que el software evalúa una <a href="#unary_predicate">predicación unaria</a>, ya ha instanciado la variable de la predicación con un <a href="#kind_of_object">tipo de objeto</a> u otro. Prueba: dado que el software rechaza las proposiciones con variables no ligadas y define todas las cuantificaciones en términos de generalizaciones universales, si se evalúa una proposición, todas las variables de esta proposición están ligadas por generalizaciones universales. Dado que el software procede desde la parte superior del árbol hacia abajo, una predicación sobre una variable solo se evalúa para evaluar la generalización universal más arriba en el árbol que liga esta variable. Debido al proceso de evaluación de generalizaciones universales, el software siempre ha instanciado esta variable en el momento en que se evalúa la predicación.</p>

<p>La predicación es cierta si el predicado es cierto del <a href="#kind_of_object">tipo de objeto</a> instanciado, y falsa si el predicado no es cierto para este tipo de objeto.</p>

<h4 id="nullary_predicate">Evaluación de una predicación sin variables (un predicado nulo)</h4> 

<p>El <a href="#kind_of_world">tipo de mundo</a> en cual el software evalúa actualmente el predicado nulo determina si este predicado nulo es cierto o falso. El tipo de mundo depende de la <a href="#evaluation_of_a_necessity">necesidad</a> más cercana por encima de la predicación en el árbol. Si no hay necesidad por encima de la predicación, el tipo de mundo se elige como parte del proceso general de <a href="#decision">decisión</a>.</p>

<h4>Evaluación de una identificación</h4>

<p>Cada vez que el software evalúa una identificación, ya ha instanciado cada una de las variables de la identificación con un <a href="#kind_of_object">tipo de objeto</a> u otro. Prueba: dado que el software rechaza las proposiciones con variables no ligadas y define todas las cuantificaciones en términos de generalizaciones universales, si se evalúa una proposición, todas las variables de esta proposición están ligadas por generalizaciones universales. Dado que el software procede de la parte superior del árbol hacia abajo, la identificación de dos variables solo se evalúa para evaluar las generalizaciones universales más arriba en el árbol que unen estas variables. Debido al proceso de evaluación de generalizaciones universales, el software siempre ha instanciado estas variables en el momento en que se evalúa la predicación.</p>

<p>La identificación es cierta si sus variables han sido instanciadas con el mismo tipo de objeto, y falsa si han sido instanciadas con dos tipos de objetos diferentes. El software asume que la identidad transmundial de los indiscernibles es imposible; siempre considera que dos objetos son tipos diferentes de objetos si son de dos tipos diferentes de mundos. <a href="http://mackwai.blogspot.com/2014/08/transworld-identity-of-indiscserables.html" target="_blank">aquí</ a>.</p>

<h3>Definiciones</h3>

<h4 id="evaluate">Evaluar</h4>

<p>Cuando el software <em>evalúa</em> una proposición, determina si es cierta o falsa según la <a href="#interpretation">interpretación</a> actual, <a href="#kind_of_world">tipo del mundo</a>, e instanciación de variables.</p>

<h4 id="decide">Decidir</h4>

<p>Cuando el software <em>decide</em> una proposición, determina si es necesariamente cierta (válida), contingente (satisfacible pero no válida) o imposible (no satisfacible).</p>

<h4 id="modality">Modalidad</h4>

<p>Una proposición gobernada por un operador modal. El software es compatible con las <a href="http://en.wikipedia.org/wiki/Alethic_modality">modalidades aleticas</a> de <a href="http://en.wikipedia.org/wiki/Logical_possibility" >posibilidad</a> y necesidad.</p>

<h4 id="unary_predicate">Predicado unario</h4>

<p>Un predicado unario es un predicado sobre una variable; el término "predicado monádico" es sinónimo, pero he elegido usar el término "predicado unario" por tres razones:</p>

<ol>
  <li>En la mayoría de los lenguajes de programación, los operadores que tienen un operando (por ejemplo, negación, inversión de bits) se denominan "operadores unarios".</li>
  <li>En la programación funcional, especialmente en el lenguaje Haskell, "monádico" es un término significativo que se relaciona con las <a href="http://en.wikipedia.org/wiki/Monad_%28category_theory%29">mónadas</a> de la teoría de categorías y no predicar sobre una variable.</li>
  <li>Las palabras "unario" y "predicado" tienen sus raíces en latín. La palabra "monádico" tiene sus raíces en griego. Entonces, llamarlo "predicado monádico" mezcla raíces lingüísticas, pero llamarlo "predicado unario" no.</li>
</ol>

<p>Un predicado unario es casi lo mismo que una propiedad. En este documento, los dos se usan indistintamente, excepto que un predicado unario "es cierta por" un objeto o "no es cierta por" un objeto, mientras que un objeto "tiene" o "no tiene" una propiedad.</p>

<p>Puede ser importante tener en cuenta que "predicado" y "predicación" son dos cosas diferentes. Un <em>predicado</em> es una proposición, propiedad o relación; una <em>predicación</em> es la aplicación de un predicado a unas variables.</p>

<h4>Predicado nulo</h4>

<p>Los predicados nulos son los mismos que las "proposiciones" en <a href="http://en.wikipedia.org/wiki/Propositional_calculus">cálculo proposicional</a>; son simplemente ciertas o falsas dentro de un mundo posible. Se pueden considerar como predicados sobre cero variables, predicados sobre nada, o sobre todo, dependiendo de cómo se mire. De ahí el término "predicado nulo".</p>

<h4>Proposición</h4>

<p>En este documento, la palabra "proposición" se usa de tres maneras diferentes, una para significar un <a href="#nullary_predicate">predicado nulo</a>, otra para significar cualquier idea que debe ser cierta o equivocada, y otra para significa una estructura de datos <a href="#parsing">construida por el software</a> que captura parte del contenido lógico de la idea que se supone que representa.</p>

<h4 id="possible_world">Mundo posible</h4>

<p>El término elegido por los filósofos para denotar cualquier forma en que el universo podría ser, o podría haber sido, si no hubiera sido lo que es.</p>

<h4 id="kind_of_world">Tipos de mundos</h4>

<p>Para decidir una proposición o evaluar una <a href="#modality">modalidad</a>, todos los <a href="#possible_world">mundos posibles</a> deben agruparse en un número finito de clases de mundos. Los siguientes párrafos describen cómo se hace esto.</p>

<p>Un predicado nulo es cierto o falso en un mundo posible. Una proposición de primer orden tiene solo un número finito de predicados nulos, por lo que con respecto a los predicados nulos en una proposición, los mundos posibles se pueden agrupar en tipos según cuáles de estos predicados nulos son verdaderos dentro de un mundo y cuáles son falsos. Para una proposición que contiene predicados nulos y ningún otro tipo de predicados, hay tantos tipos de mundos como combinaciones de predicados nulos que se pueden seleccionar de los predicados nulos en la proposición. Si una proposición contiene <em>n</em> predicados nulos, entonces hay 2<sup><em>n</em></sup> tipos de mundos para evaluar.</p>

<p>O un mundo tiene un tipo de objeto especifico o no lo tiene. Si una proposición contiene predicados unarios e identificaciones en el mundo pero no predicados nulos, los tipos de mundos que puede distinguir se definen en términos de los <a href="#kind_of_object">tipos de objetos</a> presentes o ausentes en un mundo. Si el software define <em>o</em> tipos de objetos para tal proposición, entonces define 2<sup><em>o</em></sup>-1 tipos de mundos para esa proposición. Uno se resta del número total de combinaciones porque el mundo vacío se excluye de la evaluación. El software efectivamente asume que no existe tal cosa como un mundo vacío. Si no fuera así, el software decidiría que <span class="symbolic">x,Ax&amp;~Ax</span> es posible. Tal vez debería.</p>

<p>Si una proposición contiene predicados nulos y predicados unarios o identificaciones dentro de un mundo, el software debe definir un tipo de mundo para cada combinación de predicados nulos verificados y combinaciones de tipos de objetos presentes. Este es solo el producto cartesiano de los dos, por lo que hay hasta 2<sup><em>n</em></sup>(2<sup><em>o</em></sup>-1 ) tipos de mundos que deben ser evaluados.</p>

<p>Una proposición que contiene modalidades podría involucrar <em>identificaciones transmundiales</em>, es decir, podría involucrar identificaciones cuyos sujetos podrían pertenecer a dos mundos que posible son diferentes. Por ejemplo, en &quot;<span class="symbolic">x,P&amp;&lt;&gt;(3y,y=x &amp; ~P)</span>", <span class="symbolic">y</span> está dentro de una modalidad (<span class="symbolic">&lt;&gt;</span>) de la que <span class="symbolic">x</span> está fuera y, por lo tanto, <span class= "symbolic">x</span> y <span class="symbolic">y</span> pueden pertenecer a mundos posibles que son diferentes cuando se evalúa <span class="symbolic">y=x</span>. Por ello, el software debe definir múltiples versiones de cada uno de los tipos de mundos mencionados en el párrafo anterior. Cuando hay <em>t</em> tales identificaciones transmundiales, hay hasta 2<sup><em>n</em></sup>(2<sup><em>o</em></sup>&nbsp;-&nbsp;1)&nbsp;&times;&nbsp;<em>t</em> tipos de mundos que deben ser evaluados.</p>

<h4 id="kind_of_object">Tipos de objetos</h4>

<p>Para evaluar una <a href="#universal_generalization">generalización universal</a>, todos los objetos del mundo deben agruparse en un número finito de <em>tipos de objetos</em>. Los siguientes párrafos describen cómo se hace esto.</p>

<p>Si una proposición no contiene relaciones (por ejemplo, identificaciones, predicados binarios) y contiene un número finito de propiedades, no puede distinguir entre un objeto y otro si ambos objetos tienen las mismas propiedades. Por ejemplo, <span class="symbolic">Xw-&gt;Tw</span> es falso si <span class="symbolic">w</span> se instancia con cualquiera de un número ilimitado de objetos que no tienen la propiedad <span class="symbolic">T</span> pero tienen la propiedad <span class="symbolic">X</span>, independientemente de qué otras propiedades puedan tener estos objetos. Entonces, para tal proposición, los objetos se pueden agrupar en tipos según los predicados unarios de la proposición que verifican y falsifican. Habrá 2<sup><em>u</em></sup> de estas clases, una por cada combinación de predicados unarios que se pueda elegir entre <em>u</em> predicados unarios.</p>

<p>Si una proposición contiene identificaciones, agrupar objetos por tipos es más complicado.
Dos objetos en una proposición pueden tener las mismas propiedades que se mencionan en la proposición y, sin embargo, no ser idénticos, por lo que no es suficiente definir clases solo por propiedades.
Para las identificaciones, se supone que es suficiente evaluar cada combinación de 0 a <em>i</em> de cada combinación de predicados, donde <em>i</em> es el número máximo de variables libres distintas involucradas en las identificaciones para cualquier matriz ligada por un cuantificador dentro de la proposición.
No tengo pruebas para esta suposición, pero parece funcionar.</p>

<p>En total, si hay <em>u</em> predicados unarios en una proposición y <em>i</em> es el máximo mencionado anteriormente, se deben evaluar hasta <em>i</em>2<sup><em>u</em></sup> tipos de objetos.</p>

<h4 id="interpretation">Interpretaciones</h4>

<p>Al decidir una proposición que no contiene ninguna <a href="#modality">modalidad</a>, el software define tantos tipos de mundos como sea posible bajo las suposiciones de que</p>

<ul>
  <li>Todos los predicados nulos son contingentes y no tienen necesariamente ninguna relación lógica entre sí.</li>
  <li>Todas las combinaciones de propiedades son posibles. Por ejemplo, <span class="symbolic">3x,Px&amp;Qx</span> siempre es posible, por lo tanto no pueden interpretar <span class="symbolic">P</span> y <span class="symbolic">Q</span> como "rojo" y "no rojo", respectivamente.</li>
</ul>

<p>Esto funciona para proposiciones que no contienen modalidades, pero no funcionará para proposiciones que contienen modalidades. Para proposiciones que contienen modalidades, el software debe evaluar la proposición con estos supuestos, pero también debe evaluar la proposición con cualquier otro conjunto de supuestos que es posible sobre las relaciones de los predicados nulos entre sí y con los tipos de objetos en un mundo. El software hace esto definiendo <em>interpretaciones</em>. Una <em>interpretación</em> es un conjunto de <a href="#kind_of_world">tipos de mundos</a>; contiene todo tipo de mundo que es posible bajo una interpretación dada de los predicados en la proposición, y ningún otro tipo de mundo. Para evaluar una proposición con todas las interpretaciones posibles, el software simplemente evalúa la proposición con cada subconjunto no vacío de los tipos de mundos que define para la proposición. Entonces, si hay tipos de mundos <em>u</em> para una proposición, entonces hay 2<sup><em>u</em>-1</sup> interpretaciones que deben evaluarse.</p>


<h2>Notas</h2>

<h3>Semántica de la lógica modal cuantificada</h3>

<h4>Identidad transmundial</h4>

<p>Parece común en las discusiones sobre la lógica modal cuantificada suponer que dos objetos en dos mundos posibles diferentes pueden ser idénticos de alguna manera; se consideran el mismo objeto.
En todas las lógicas modales cuantificadas que he encontrado, el operador de igualdad ("<span class="symbolic">=</span>") significa este tipo de identidad.
Desarrollé el manejo de este software de la lógica modal cuantificada sin saber que este tipo de identidad era lo que normalmente se usaba en la lógica modal cuantificada y, en consecuencia, hice que "<span class="simbólico">=</span>" indicara el único tipo de identidad que sabía estaba bien definida: identidad de indiscernibles.
Esto causa el modal cuantificado del software ser inusual, pero espero que no sea inútil.
Es posible representar la identidad común en el lenguaje del software.
Considere lo que significa que dos objetos en dos mundos diferentes sean el mismo objeto.
Si digo "Si no me hubiera sentido tan mal el lunes, habría ido a trabajar", estoy hablando de dos mundos posibles: el mundo real y un mundo contrafactual donde fui a trabajar el lunes, pero estoy hablando de una persona que existe en ambos mundos.
Pero, ¿qué es lo que los hace iguales?
Mi primera suposición sería que comparten una propiedad en común &mdash; el de ser <em>yo</em> &mdash; y cada uno de ellos es el único objeto en su respectivo mundo que tiene esa propiedad, pero no es tan simple.
En algún otro mundo, George Washington podría no haber sido el primer presidente de los Estados Unidos de América.
Si empezáramos a escribir una historia alternativa sobre los EE. UU. como hubiera sido si George Washington nunca hubiera sido presidente, probablemente consideraríamos que el George Washington que no es presidente es la misma persona que el George Washington real, pero no consideraríamos a quien sea. De lo contrario, elegimos ser el primer presidente para ser la misma persona que el primer presidente real de los EE. UU., aunque son los únicos poseedores de la propiedad de ser el primer presidente de los EE. UU. en sus respectivos mundos.
¿Por qué?
Esta es una pregunta interesante, pero para los propósitos inmediatos de escribirla como una declaración simbólica, no necesita respuesta.</p>

<p>Para capturar esta noción de identidad que se usa habitualmente en la lógica modal en este lenguaje, elegiríamos un predicado para representar la propiedad que se supone que los dos objetos tienen en común, afirmaríamos que no más de un objeto en un mundo puede tener esa propiedad, y luego afirmar que ambos objetos tienen esta propiedad. Por ejemplo:</p>

<pre class="symbolic">// En cualquier mundo, solo puede haber un primer presidente de los EE. UU.
[]x,y, Px&Py -> x=y

// George Washington fue el primer presidente de los Estados Unidos.
x,Gx -> Px

// George Washington podría no haber sido el primer presidente de los Estados Unidos.
<>3x,Gx&~Px
</pre>

<p>Desafortunadamente, el software no admite declaraciones de esta complejidad, y por lo tanto no puede decidir declaraciones que utilicen esta representación de identidad transmundial.</p>

<h4>Instanciacións de objetos dentro de expresiones modales</h4>

<p>Los cuantificadores siempre se evalúan dentro de un tipo de mundo. Solo se extienden sobre los objetos que existen en este tipo de mundo. No estoy seguro de si debería llamarlo "actualist", pero la idea es al menos similar a la idea en <a href="http://www.amazon.com/Possible-Worlds-Rod-Girle/" de Rod Girle dp/0773526684"><em>Mundos posibles</em></a>. Entonces, cada vez que se crea una instancia de una variable con un tipo de objeto, se fija el tipo de mundo en el que existe. Esto implica que "<span class="symbolic">x, Px -&gt; []Px</span>" es necesariamente cierto. Si quisiera expresar la proposición <em>si algo es P, entonces necesariamente es P</em>, podría usar la formulación de identidad transmundial descrita anteriormente:</p>

<pre class="symbolic">// Elija R arbitrariamente.
[]x,y, Rx&Ry -> x=y // En cualquier mundo, no hay más de una R.

x, Rx & (Px -> []y, Ry -> Py)
</pre>

<p>Desafortunadamente, esta expresión implica demasiadas interpretaciones y el software la rechazará.</p>


<h3>Eficiencia y limitaciones del tiempo de ejecución</h3>

<p>Como se puede ver al combinar las fórmulas dadas en las secciones sobre <a href="#kind_of_object">tipos de objetos</a>, <a href="#kind_of_world">tipos de mundos</a> y <a href="#interpretation">interpretaciones</a>, para decidir una propuesta sin modalidades, el software debe evaluar la propuesta en hasta <span style="font-size: medium;">2<sup><em>n</em></sup>&nbsp;&times;&nbsp;Max(0,&nbsp;2<sup><em>i</em>2<sup><em>u</em></sup></sup>&nbsp;-&nbsp;1)</span> tipos de mundos, donde <em>n</em> es el número de predicados nulos distintos en la proposición, <em>u</em> es el número de predicados unarios distintos en la proposición, y <em>i</em> es el número máximo de variables libres distintas que son involucradas en identificaciones para cualquier matriz limitada por un cuantificador dentro de la proposición, o 1 si la proposición contiene variables pero no identificaciones, o 0 si la proposición no contiene variables. Para decidir una proposición con modalidades, el software debe evaluar la proposición en hasta <span style="font-size: large;">2<sup>2<sup><em>n</em></sup>&nbsp ;&times;&nbsp;Max(0,&nbsp;2<sup><em>i</em>2<sup><em>u</em></sup></sup>&nbsp;-&nbsp;1) </sup></span> interpretaciones. Esto significa que el algoritmo no escala bien; su tiempo de ejecución es exponencial o superexponencial en relación con la complejidad de la proposición que se decide. Sin embargo, esto no impide que el software funcione lo suficientemente rápido al decidir proposición con valores pequeños para <em>n</em>, <em>u</em> y <em>i</em>.</p>

<p>En realidad, el software define <em>i&#772;</em>2<sup><em>u</em></sup> tipos de objetos, donde <em>i&#772;</em> es <em >i</em> redondeado a la potencia de 2 más cercana. No es necesario que <em>i</em> se redondee para que el algoritmo sea correcto, pero facilita la codificación de tipos de objetos como números binarios. Además, para mantener la codificación binaria simple, define mundos vacíos, pero los omite al evaluar las proposiciones. El software en realidad codifica tipos de mundos e interpretaciones como números binarios de 32 bits. Esto permite que el software funcione rápido, pero pone un límite estricto a la complejidad de las propuestas que puede decidir; <span style="font-size: medium;"><em>n</em><em>&nbsp;+&nbsp;i&#772;</em>2<sup><em>u</em></sup>&nbsp;&le;&nbsp;32</span> para proposiciones no modales y <span style="font-size: medium;">2<sup><em>n</em>&nbsp;+&nbsp; <em>i&#772;</em>2<sup><em>u</em></sup></sup> &le; 32</span> para proposiciones modales.</p>

<p>Las siguientes tablas enumeran los valores combinados más grandes de <em>n</em>, <em>u</em> y <em>i</em> que admite el software.</p>

<table id="maxima_for_modal_propositions">
  <caption>Maxima para proposiciones modales</caption>
  <tr><td>5</td><td>0</td><td>0</td></tr>
  <tr><td>4</td><td>0</td><td>2</td></tr>
  <tr><td>3</td><td>1</td><td>2</td></tr>
  <tr><td>3</td><td>0</td><td>4</td></tr>
  <tr><td>2</td><td>0</td><td>8</td></tr>
  <tr><td>1</td><td>2</td><td>2</td></tr>
  <tr><td>1</td><td>1</td><td>4</td></tr>
  <tr><td>1</td><td>0</td><td>16</td></tr>
  <tr><td>0</td><td>0</td><td>17</td></tr>
</table>

<table id="maxima_for_non_modal_propositions">
  <caption>Maxima para proposiciones no modales</caption>
  <tr><td>32</td><td>0</td><td>0</td></tr>
  <tr><td>31</td><td>0</td><td>2</td></tr>
  <tr><td>30</td><td>1</td><td>2</td></tr>
  <tr><td>30</td><td>0</td><td>4</td></tr>
  <tr><td>29</td><td>0</td><td>8</td></tr>
  <tr><td>28</td><td>2</td><td>2</td></tr>
  <tr><td>28</td><td>1</td><td>4</td></tr>
  <tr><td>28</td><td>0</td><td>16</td></tr>
  <tr><td>27</td><td>0</td><td>17</td></tr>
  <tr><td>26</td><td>1</td><td>8</td></tr>
  <tr><td>24</td><td>3</td><td>2</td></tr>
  <tr><td>24</td><td>2</td><td>4</td></tr>
  <tr><td>24</td><td>1</td><td>16</td></tr>
  <tr><td>22</td><td>1</td><td>17</td></tr>
  <tr><td>20</td><td>2</td><td>8</td></tr>
  <tr><td>16</td><td>4</td><td>2</td></tr>
  <tr><td>16</td><td>3</td><td>4</td></tr>
  <tr><td>16</td><td>2</td><td>16</td></tr>
  <tr><td>12</td><td>2</td><td>17</td></tr>
  <tr><td>8</td><td>3</td><td>8</td></tr>
  <tr><td>0</td><td>5</td><td>2</td></tr>
  <tr><td>0</td><td>4</td><td>4</td></tr>
  <tr><td>0</td><td>3</td><td>16</td></tr>
</table>

<h3>Contacto</h3>

<p>Puede ponerse en contacto conmigo (el desarrollador de esta aplicación) enviándome un correo electrónico a <span id="a"><span id="sgnimuc" class="backwards">g@sgnimuc.eiznekcam</span>mail.com</span> o agregando un comentario a <a href="http://mackwai.blogspot.com/2014/11/feedback-for-somerbynetmacklogic.html" target="_blank">esta publicación de blog</a>. Estoy dispuesto a responder preguntas o brindar ayuda sobre el uso del software.</p>

<p>Me harías un favor si me avisaras de<p>

<ul>
  <li>errores en el software,</li>
  <li>decisiones incorrectas tomadas por el software, o</li>
  <li>declaraciones poco claras o equivocadas en este documento.</li>
</ul>

<p>También,</p>

<ul>
  <li>Si encuentra útil esta aplicación, me gustaría saber para qué la usa.</li>
  <li>Si hay alguna parte de la interfaz de usuario que encuentra confusa, dígame e intentaré mejorarla.</li>
  <li>Si tiene ideas para nuevas funciones, no dude en sugerirlas. Estoy abierto a expandir la funcionalidad de esta aplicación, siempre y cuando esté en consonancia con el enfoque basado en los mundos posibles que el software utiliza para decidir propuestas.</li>
</ul>

<p id="feedback">Gracias.</p>

</div>

<script type="text/javascript">
function ReverseString(s)
{
    return s.split("").reverse().join("");
}
function sgnimuc()
{
  var sgnimuc = document.getElementById("sgnimuc");
  sgnimuc.className = sgnimuc.className.replace( /(?:^|\s)backwards(?!\S)/g , '' );
  sgnimuc.innerHTML = ReverseString(sgnimuc.innerHTML);
  var a = document.getElementById("a");
  if ( !(a.textContent === undefined) )
    a.innerHTML = "<a href=\"mailto:" + a.textContent + "\">" + a.innerHTML + "</a>";
}
</script>

</body>
</html>