<!DOCTYPE html>
<!--
  somerby.net/mack/logic
  Copyright (C) 2015, 2023 MacKenzie Cumings
 
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-->

<html>
<head lang="en">
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Information for somerby.net/mack/logic</title>

<link rel="stylesheet" href="../style.css" type="text/css" />

</head>
<body onload="sgnimuc()">

<div id="text_column">

<h3><a href="index.html">&#8666; home</a></h3>

<h1>somerby.net/mack/logic</h1>

<h2 id="introduction">Introduction</h2>

<p>This web application (herein referred to as &quot;the software&quot; or &quot;application&quot;) decides the validity/satisfiablity/inconsistency of certain kinds of statements in symbolic logic.</p>

<p>Most of the software is written in C# and translated into JavaScript with <a href="http://www.saltarelle-compiler.com/" target="_blank">Saltarelle</a>.  The source code is on <a href="https://github.com/mackwai/UnaryPredicateLogic" target="_blank">GitHub</a>.  <a href="https://github.com/mdaines/viz.js/">Viz.js</a> is used to generate diagrams.  The truth table feature is adapted from <a href="https://github.com/mrieppel/TruthTableGenerator" target="_blank">code</a> written by Michael Rieppel.</p>

<p>Thanks to Maximiliano Paesani for his help in translating the web application into Spanish.  <em>Gracias a Maximiliano Paesani para su ayuda en la traducción de esta aplicación.</em></p>

<h2 id="instructions">Instructions</h2>

<p>To use this application, type a logical statement into the textbox on the main page, then click the "Decide" button.
If the application can decide the statement, it will.  Otherwise, it will show some kind of error message describing what went wrong.
The <a href="#the_language">language section</a> explains how to write logical statements for this application.
If you're looking for examples of statements, click on any of the buttons under the heading entitled "Examples" and the application will fill the text box with an example statement, ready to be decided.</p>

<p>If you click "Depict" button, the application will draw a diagram that shows how the application interprets the statement in the textbox.
This diagram is a graphical representation of the data structure that the application actually uses to decide the statement.</p>

<p>If there is a syntactically valid propositional logic statement in the textbox, the "Truth Table" button will be enabled.
Clicking this button will cause the application to draw a <a href="http://en.wikipedia.org/wiki/Truth_table" target="_blank">truth table</a> for the statement.</p>

<p>Clicking the "Example" button will cause the application to attempt to find a kind of world where the statement is true.
If it succeeds, it will show a description of that kind of world.</p>

<p>Clicking the "Counterexample" button will cause the application to attempt to find a kind of world where the statement is false.
If it succeeds, it will show a description of that kind of world.</p>

<p>Clicking the "Tree Proof" button will pass the statement to wo's <a href="http://www.umsu.de/logik/trees" target="_blank">Tree Proof Generator</a>.
It is a web application that uses Semantic Tableaux to check the validity of a statement, and provides a proof if it finds that the statement is valid.
The "Tree Proof" button will be enabled whenever there is a syntactically valid statement in the text box that does not contain identifications or modal operators.
If you want to evaluate a statement that contains binary predicates (relations), use the Tree Proof Generator.</p>

<h2 id="the_language">The Language</h2>

<h3>Elements of the Language</h3>

<p>The language has these elements:</p>

<ul>
  <li><a href="#language_logical_operators">Unary and binary logical operators</a></li>
  <li><a href="#language_variable">Variables</a></li>
  <li><a href="#language_constant">Individual Constants</a></li>
  <li>Predicates on <a href="#language_unary_predicate">one variable</a> (properties) and predicates on <a href="#language_nullary_predicate">zero variables</a> (propositions)</li>
  <li>Predicates on <a href="#language_binary_predicate">two variables</a> (relations)</li>
  <li><a href="#language_grouping">Grouping</a> with parentheses</li>
  <li><a href="#language_universal_generalization">Universal generalizations</a>, <a href="#language_existential_quantification">existential quantifications</a> and <a href="#language_definite_description">definite descriptions</a></li>
  <li><a href="#language_identity">Identity</a></li>
  <li><a href="#language_modal_operators">The modal operators for necessity and possibility</a></li>
  <li><a href="#language_two_term_propositions">Two-term propositions</a></li>
  <li><a href="#language_assertions_of_number">Some simple assertions of number</a></li>
  <li><a href="#text_replacements">Text replacements</a></li>
  <li><a href="#language_therefore">A "therefore" symbol</a></li>
</ul>

<h4 id="language_logical_operators">Logical Operators</h4>

<p>The logical operators recognized by the software are:</p>

<table>
  <tr><th>Operator</th><th>Symbol</th><th>Description</th></tr>
  <tr><td>negation</td>             <td><span class="symbolic">~</span></td>        <td>Logical NOT</td></tr>
  <tr><td>conjunction</td>          <td><span class="symbolic">&amp;</span></td>    <td>Logical AND</td></tr>
  <tr><td>disjunction</td>          <td><span class="symbolic">|</span></td>        <td>Logical OR</td></tr>
  <tr><td>material conditional</td> <td><span class="symbolic">-&gt;</span></td>    <td>if &hellip; then &hellip;</td></tr>
  <tr><td>biconditional</td>        <td><span class="symbolic">&lt;=&gt;</span></td><td>Logical equivalence</td></tr>
  <tr><td>joint denial</td>         <td><span class="symbolic">!</span></td>        <td>Logical NOR</td></tr>
  <tr><td>exclusive disjunction</td><td><span class="symbolic">^</span></td>        <td>Logical XOR</td></tr>
  <tr><td>strict implication</td><td><span class="symbolic">-&lt;</span></td>        <td>necessarily if &hellip; then &hellip;</td></tr>
</table>

<p>The binary logical operators all are left-associative and have the following precedences:</p>

<table>
  <tr><th>Precedence</th><th>Operators</th></tr>
  <tr><td>highest</td>  <td><span class="symbolic">&amp;</span>, <span class="symbolic">!</span></td></tr>
  <tr><td>&hellip;</td> <td><span class="symbolic">|</span></td></tr>
  <tr><td>&hellip;</td> <td><span class="symbolic">-&gt;</span>, <span class="symbolic">-&lt;</span></td></tr>
  <tr><td>lowest</td>   <td><span class="symbolic">&lt;=&gt;</span>, <span class="symbolic">^</span></td></tr>
</table>

<p>For example,</p>

<pre class="symbolic">A|B&amp;C-&gt;D</pre>

<p class="continuation">is interpreted to mean the same as</p>

<pre class="symbolic">(A|(B&amp;C))-&gt;D</pre>

<p>Negation is right-associative and has higher precedence than any of the binary operators, so</p>

<pre class="symbolic">~P &amp; ~Q</pre>

<p class="continuation">is interpreted to mean the same as</p>

<pre class="symbolic">(~P) &amp; (~Q)</pre>

<h4 id="language_variable">Variables</h4>
<p>A variable is a single lowercase letter that represents the object of a quantification.
A lowercase letter in a predication will be interpreted as a variable if the predication is a subexpression of a quantifier.
It will be bound to the nearest enclosing quantifier.</p>

<h4 id="language_constant">Individual Constants</h4>
<p>Individual constants, like <a href="#language_variable">variables</a>, are single lowercase letters.
Any lowercase letter in a predication will be interpreted as an individual constant if the predication is not bound by a quantifier.
As far as I can tell, individual constants are not necessary in a symbolic logic, in that the idea of a named individual could be expressed with other symbols.
This argument</p>

<pre class="symbolic">Hx-&gt;Mx // All men are mortal.
Hs     // Socrates is a man.
-&gt;     // Therefore
Ms     // Socrates is mortal.</pre>

<p class="continuation">could also be represented without individual constants as</p>

<pre class="symbolic">Hx-&gt;Mx                                   // All men are mortal.
(3x,Sx) &amp; ([]x,Sx-&gt;y,Sy-&gt;x=y) &amp; x,Sx->Hx // Socrates is a man.
-&gt;                                       // Therefore
x,Sx->Mx                                 // Socrates is mortal.</pre>

<p class="continuation">It is more complicated, but it is in one respect better in that it makes explicit what we usually assume about Socrates, which is that he exists and he is, by definition, a unique individual.
Even so, I think individual constants are too convenient a feature to be omitted from the software.
The use of an individual constant implies that the object denoted by the individual constant exists.
Because of this, the software will decide that <span class="symbolic">3x,x=g</span> is necessarily true.
This isn't the only way to interpret individual constants, but it is the easiest interpretation to implement in this software.
Possible objects (ones which may or may not exist) and impossible objects (ones which could never exist), can be represented with unary predicates.</p>

<p>Since I have not yet found a satisfactory way to <a href="#decide">decide</a> statements which contain both modal operators and individual constants, the software rejects any statement that contains both modal operators and individual constants.</p>

<h4 id="language_nullary_predicate">Predicates on Zero Variables</h4>

<p>A predicate on zero variables, which can be thought of as representing a true/false proposition, is represented by a single letter.</p>

<h4 id="language_unary_predicate">Predicates on One Variable</h4>

<p>A predication on one variable, which can be thought of as the assertion that an object has some property, is represented by a single capital letter (the predicate) followed by a single lowercase letter (the variable).  You can use the same capital letter as a predicate over one variable and as a predicate over zero variables in the same statement and the software will treat them as distinct predicates, for example</p>

<pre class="symbolic">x,Fx-&gt;F</pre>

<p class="continuation">will be interpreted in the same way as</p>

<pre class="symbolic">x,Fx-&gt;P</pre>

<p class="continuation">because the first &quot;<span class="symbolic">F</span>&quot; is interpreted as a unary predicate and the second &quot;<span class="symbolic">F</span>&quot; is interpreted as a nullary predicate.</p>

<h4 id="language_binary_predicate">Predicates on Two Variables</h4>

<p>A predication on two variables, which can be thought of as the assertion that two objects have some relation to each other, is represented by a single capital letter (the predicate) followed by two lowercase letters (the variables).
The decision algorithm does not support predicates on two variables, and will usually reject a statement that contains them.
Statements that have predicates on two variables can, however, be evaluated with the Tree Proof Generator, if they do not also contain <a href="#language_modal_operators">modal operators</a> or <a href="#language_identity">identifications</a>.</p>

<h4 id="grouping">Grouping</h4>

<p>Expressions can be grouped together with parentheses.  They work just like parentheses do in algebra or in other symbolic logics.</p>

<h4 id="language_universal_generalization">Universal Generalizations</h4>

<p>A universal generalization is a variable followed by a comma followed by the expression the generalization applies to.  So you could type</p>

<pre class="symbolic">x,Ax</pre>

<p class="continuation">to mean "everything is awesome".  The generalization will apply to everything in the expression that follows the comma, up until an enclosing parenthesis or the end of the line of text that the generalization is on.  So</p>

<pre class="symbolic">x,Fx &amp; y,Jy</pre>

<p class="continuation">is a generalization over</p>

<pre class="symbolic">Fx &amp; y,Jy</pre>

<p class="continuation">and not just a generalization over <span class="symbolic">Fx</span>.  I recommend adding parentheses to make things clear, like</p>

<pre class="symbolic">(x, Fx &amp; (y,Jy))</pre>

<p>A variable is always bound to the nearest enclosing generalization, so for</p>

<pre class="symbolic">x, (x,F-&gt;Px) &amp; Jx</pre>

<p class="continuation">the <span class="symbolic">x</span> in <span class="symbolic">Px</span> is bound to the second universal generalization and the <span class="symbolic">x</span> in <span class="symbolic">Jx</span> is bound to the first universal generalization.</p>


<h4 id="language_existential_quantification">Existential Quantifications</h4>

<p>An existential quantification is a "<span class="symbolic">3</span>" followed by a variable followed by a comma followed by the expression that the quantification applies to.  For example,</p>

<pre class="symbolic">3x, Fx &amp; Bx</pre>

<p>Could mean "There is a fountain filled with blood".  The same rules for applicability and binding of variables that apply to universal generalizations also apply to existential quantifications.</p>

<h4 id="language_definite_description">Definite Description</h4>

<p>A definite description is a "<span class="symbolic">1</span>" followed by a variable followed by a comma followed by an expression that is supposed to describe exactly one object.  For example,</p>

<pre class="symbolic">1x,Rx</pre>

<p>Could mean "there is only one Roy Orbison".</p>

<h4 id="language_identity">Identity</h4>

<p>An identification of two objects is just a lowercase letter followed by an equals sign followed by another lowercase letter, for example</p>

<pre class="symbolic">x,y, (Fx &amp; x=y) -&gt; Fy</pre>

<p class="continuation">is a statement where "<span class="symbolic">x=y</span>" means <span class="symbolic">x</span> is the same object as <span class="symbolic">y</span>.</p>

<h4 id="language_modal_operators">Modal Operators</h4>

<p>The software recognizes two modal operators, "<span class="symbolic">[]</span>" for necessity and "<span class="symbolic">&lt;&gt;</span>" for possibility.  They are right-associative and have the same precedence as negation.  The kind of modality represented by these operators is <a href="http://en.wikipedia.org/wiki/Alethic_modality">alethic</a> modality.</p>

<h4 id="language_two_term_propositions">Two-term Propositions</h4>

<p>The software recognizes the two-term propositions of what is variously called <a href="http://en.wikipedia.org/wiki/Term_logic" target="_blank">"term", "Aristotelian" or "traditional" logic</a>.  It treats two-term propositions as shorthand statements of unary predicate logic.  They are a capital letter representing the subject term, followed by a lower-case letter representing the proposition's form, followed by a capital letter representing the predicate term.</p>

<table>
  <tr><th>Symbol</th><th>Proposition</th><th>Definition</th></tr>
  <tr><td><span class="symbolic">SaP</span></td><td>All S are P</td>                      <td><span class="symbolic">(x,Sx-&gt;Px)&amp;(3x,Sx)</span></td></tr>
  <tr><td><span class="symbolic">SeP</span></td><td>No S are P</td>                       <td><span class="symbolic">x,Sx-&gt;~Px</span></td></tr>
  <tr><td><span class="symbolic">SiP</span></td><td>Some S is P</td>                      <td><span class="symbolic">3x,Sx&amp;Px</span></td></tr>
  <tr><td><span class="symbolic">SoP</span></td><td>Not all S are P</td>                  <td><span class="symbolic">(3x,Sx&amp;~Px)|(~3x,Sx)</span></td></tr>
  <tr><td><span class="symbolic">SuP</span></td><td>Either all S are P or no S are P </td><td><span class="symbolic">(x,Sx-&gt;Px)|(x,Sx-&gt;~Px)</span></td></tr>
  <tr><td><span class="symbolic">SyP</span></td><td>Some S are P and some S are not P</td><td><span class="symbolic">(3x,Sx&amp;Px)&amp;(3x,Sx&amp;~Px)</span></td></tr>
</table>

<p>In order to make the traditional <a href="http://en.wikipedia.org/wiki/Square_of_opposition" target="_blank">Square of Opposition</a> hold true, the A-form proposition is given existential import and the O-form proposition is denied existential import, per what was argued by <a href="http://plato.stanford.edu/entries/square/" target="_blank">Terence Parsons</a>.  It also recognizes the U-form and Y-form of the <a href="http://en.wikipedia.org/wiki/Logical_hexagon">Hexagon of Opposition</a>.</p>

<p>Either term in a proposition can be negated by adding the "<span class="symbolic">~</span>" symbol, for instance, "<span class="symbolic">~Aa~B</span>" will be interpreted as "all non-A are non-B".  A "<span class="symbolic">~</span>" at the front of the expression attaches to the first term and not to the whole expression, so "<span class="symbolic">~Aa~B</span>" is interpreted to mean the same as "<span class="symbolic">(~Aa~B)</span>" and not the same as "<span class="symbolic">~(Aa~B)</span>".</p>

<h4 id="language_assertions_of_number">Assertions of Number</h4>

<p>The language includes a means to make some simple assertions of number.  I added them to the language just for convenience; they sometimes help when codifying the logic in certain logic puzzles.  They don't belong to any symbolic logic that I know of.</p>

<p>A nonnegative integer <em>n</em> followed by a single capital letter <em>P</em>is an assertion that exactly <em>n</em> objects have the property <em>P</em>.</p>

<p>A nonnegative integer <em>n</em> followed by more than one capital letter <em>P, Q, &hellip;</em> is an assertion that exactly <em>n</em>  of the propositions <em>P, Q, &hellip;</em> are true.<p/>

<table>
  <tr><th>Example</th><th>Meaning</th></tr>
  <tr><td><span class="symbolic">0P</span></td><td>No objects are P</td></tr>
  <tr><td><span class="symbolic">1P</span></td><td>Exactly 1 object is P</td></tr>
  <tr><td><span class="symbolic">2P</span></td><td>Exactly 2 objects are P</td></tr>
  <tr><td><span class="symbolic">0PQR</span></td><td>None of P, Q and R are true</td></tr>
  <tr><td><span class="symbolic">1PQR</span></td><td>Only one of P, Q and R is true</td></tr>
  <tr><td><span class="symbolic">2PQR</span></td><td>Exactly 2 of P, Q and R are true</td></tr>
</table>

<h4 id="text_replacements">Text Replacements</h4>

<p>A line that begins with "<span class="symbolic">#replace</span>" will be interpreted as a directive to replace one string of letters or symbols with another in the lines below the directive.  It's a way to define your own operator symbols or give meaningful names to predicates and variables. For example, when given the text</p>

<pre class="symbolic">#replace => ->
#replace man H
#replace mortal M
#replace socrates s
#replace therefore .'.

x, man x => mortal x
man socrates
therefore
mortal socrates</pre>

<p class="continuation">the application will convert it to</p>

<pre class="symbolic">
x, H x -> M x
M s
.'.
M s</pre>

<p class="continuation">before parsing it.</p>

<h4 id="language_therefore">The "Therefore" Symbol</h4>

<p>The "therefore" symbol, "<span class="symbolic">.'.</span>" (period apostrophe period) can be used to test logical arguments.  It will be evaluated the same way as the <a href="#material_conditional">material conditional</a>, but the result displayed will be different.  Instead of indicating if the argument is necessarily true, contingent, or impossible, the software will indicate if the argument is valid (necessarily true) or invalid (not necessarily true).  Additionally, if the argument is valid, the software will indicate if the premises are inconsistent or the conclusion is tautological.</p>

<h3>Valid Expressions</h3>

<p class="continuation">A valid expression in this language is just a true/false statement.  It may be a single line, like</p>

<pre class="symbolic">P&amp;Q-&gt;R</pre>

<p class="continuation">or it may be multiple lines, like</p>

<pre class="symbolic">Hx-&gt;Mx
Hs
-&gt;
Ms</pre>

<p>If it is a single line, the software interprets the line as a statement and decides whether it is valid, satisfiable, or self-contradictory.  If it is multiple lines, the software joins those lines to be a single expression and decides that statement.  The software treats each line that is a statement as if it were conjoined to the other lines that are statements with a logical AND.  This enables you to spread a long statement across multiple lines. For example,</p>

<pre class="symbolic">P-&gt;Q
Q-&gt;R
P</pre>

<p class="continuation">is interpreted to mean the same as</p>

<pre class="symbolic">(P-&gt;Q)&amp;(Q-&gt;R)&amp;P</pre>

<p>If an expression has several lines and exactly one of them is a single binary logical operator or the "therefore" symbol, the software will join the lines before the operator with a logical AND, join the lines after the operator with a logical AND, and then join these two conjuncts with the single logical operator.  For example,</p>

<pre class="symbolic">Hx-&gt;Mx
Hs
-&gt;
Ms</pre>

<p class="continuation">is interpreted to mean the same as</p>

<pre class="symbolic">( (Hx-&gt;Mx) &amp; Hs ) -&gt; (Ms)</pre>

<p>This enables you to express a logical argument - several premises followed by a conclusion - in a familiar way, or test if one set of statements is equivalent to another set of statements without putting them all on one line.</p>

<p>Long statements can be broken up across several lines.  The software will interpret text on several lines as one statement according to the following rules:</p>
<ul>
  <li>If a line starts between opening and closing parentheses, it will be joined with the preceding line.</li>
  <li>If a line ends with a binary operator, it will be joined to the next line.</li>
  <li>If a line begins with a binary operator, it will be joined with the preceding line.</li>
<p>For example, the following text blocks are all interpreted the same way:</p>

<ul>
  <li><pre class="symbolic">x,Ax|Bx|Cx</pre></li>
  <li><pre class="symbolic">x,Ax
|Bx
|Cx</pre></li>
<li><pre class="symbolic">x,Ax|
Bx|
Cx</pre></li>
  <li><pre class="symbolic">(x,
Ax|Bx|Cx)</pre></li>
</ul>

<h4>Whitespace</h4>

<p>Tabs, spaces and empty lines are always ignored.  You could type this:</p>

<pre class="symbolic">((A   |B|C)-&gt;J )&lt;=&gt;x,F    x&amp;             y,Ix</pre>

<p class="continuation">or this:</p>

<pre class="symbolic">(  (A | B |C      )-&gt;J)&lt;=&gt;         x  ,Fx&amp;y,I     x</pre>

<p class="continuation">and expect the same result.  Whitespace can be used to make expressions easier to read.  But would probably want to type this instead:</p>

<pre class="symbolic">((A|B|C) -&gt; J ) &lt;=&gt; x, Fx &amp; y,Ix</pre>

<p class="continuation">because it's easier to read.</p>

<h3>Comments</h3>

<p>A "<span class="symbolic">//</span>" and anything following it on a line is ignored by the software.  This enables you to add helpful comments to expressions, like</p>

<pre class="symbolic">Hx-&gt;Mx // All men are mortal.
Hs     // Socrates is a man.
.'.     // Therefore
Ms     // Socrates is mortal.</pre>

<h3>Criteria for the Design of the Language</h3>

<p>The language this tool uses is a kind of symbolic logic.  It was designed with these criteria in mind:</p>

<ul>
  <li>The language should only use basic ASCII characters which are available on a standard English keyboard, so typing expressions in the language is easy.</li>
  <li>The language's constructs should use few characters so they can be typed quickly.</li>
  <li>The language should enable a person to arrange statement in such a way that it is easy to read.</li>
  <li>The symbols defined in the language should have a precedent in other languages.  The symbols in this language are borrowed from conventional symbolic logic, conventional mathematical notation, and the C programming language.</li>
</ul>

<h2 id="the_algorithm">The Algorithm</h2>

<p>When the software is <a href="#decide">decides</a> a proposition, it does not operate on symbolic statements.  It operates on a <a href="http://en.wikipedia.org/wiki/Tree_%28data_structure%29">tree</a>-like data structure that is meant to represent the proposition.  In this &quot;tree&quot;, each node is an element in the proposition (a predicate, a variable, a quantifier, etc.) and each edge is a dependency between an element and its subordinate elements (e.g. a logical AND is a node with edges pointing to the two elements on either side of it).</p>

<h3 id="parsing">Parsing</h3>

<p>The first step the software takes is to read the text given to it and attempt to convert it to a &quot;tree&quot;.  If it succeeds, the text is a well-formed statement within the software's symbolic language and the software can <a href="#decide">decide</a> the tree.  There is more than one way this parsing could be done, so the details are not important, as long as the resulting tree is correct.</p>

<p>The exact choice of language isn't important to the decision process, either.  So long as a language only represents logical elements that are supported by the software and the language does not allow any logical element to depend on itself, directly or indirectly (e.g. no Liar's Paradoxes), that language could replace the language that is recognized by this software and the decision algorithm would work the same way.</p>

<p id="replacement">For certain elements which can be defined in terms of other elements, the software makes substitutions:</p>

<table id="substitutions">
  <caption>Substitutions</caption>
  <tr><th></th><th>Element</th><th>Replacement</th></tr>
  <tr><td><span class="symbolic">3x,...</span></td><td>existential quantification</td><td><span class="symbolic">(~x,~...)</span></td></tr>
  <tr><td><span class="symbolic">1x,...</span></td><td>definite description</td><td><span class="symbolic">(3y,x, x=y &lt;=&gt; ...)</span></td></tr>
  <tr><td><span class="symbolic">&lt;&gt;...</span></td><td>possibility</td><td><span class="symbolic">(~[]~...)</span></td></tr>
  <tr><td><span class="symbolic">...^...</span></td><td>exclusive disjunction</td><td><span class="symbolic">~(...&lt;=&gt;...)</span></td></tr>
</table>

<p>It might be helpful to show some symbolic statements and what their corresponding trees look like.  For the statement <span class="symbolic">w,Xw-&gt;Tw</span>, which might be interpreted as "all my exes live in Texas", the software creates a tree like this:</p>

<img src="../ExesInTexas.png" alt="graph of 'All my exes live in Texas.'" />

<p>The elements of the statement are all there: a universal generalization, a material implication beneath it, and two predications beneath that.  The whole declares a logical relationship between being George Strait's ex and living in Texas.</p>

<p>More complicated statements have more complicated trees.  For the syllogism</p>

<pre class="symbolic">
x,Hx-&gt;Mx // All men are mortal;
Hs       // Socrates is a man;
-&gt;       // therefore
Ms       // Socrates is mortal.
</pre>

<p class="continuation">the software creates this tree:</p>

<img src="../Socrates.png" alt="graph of a syllogism" />

<p>The argument has been converted to a single proposition; the software will decide whether or not the argument is valid by deciding whether or not this proposition is necessarily true.</p>

<h3 id="decision">Decision</h3>

<p>The software operates on trees like the ones described above.  To decide a proposition, for each <a href="#kind_of_world">kind of world</a>, and sometimes for each kind of world in each <a href="#interpretation">interpretation</a>, the software determines whether the proposition represented by the tree is true or false. If is is found to be true in each kind of world, it is decided to be necessary.  If it is found to be false in each kind of world, it is decided to be impossible.  If it is found to be true in some kind of world and false in another, it is decided to be contingent.  The software works from the top down.  Each node in the tree is <a href="#evaluate">evaluated</a> by evaluating its subordinate nodes; they in turn are evaluated by evaluating their subordinate nodes.  The procedure for evaluating a node depends on what kind of logical element it represents; each logical element has its own procedure.  The following sections define procedures followed for each logical element.</p>

<p>If the proposition does not contain any <a href="#modality">modalities</a> or individual constants, the proposition is decided by evaluating the tree for each kind of world.  This effectively tests the proposition in every <a href="#possible_world">possible world</a>, and therefore is sufficient to decide whether the proposition is necessarily true, contingent, or impossible.</p>

<p>If the proposition contains individual constants, the proposition is decided by deciding two other propositions.  The first proposition is formed by binding all individual constants in the original proposition with universal generalizations.  If this proposition is true, then the original proposition is necessarily true.  The second proposition is formed by binding all individual constants in the original proposition with existential quantifiers.  If this proposition is impossible, then the original proposition is impossible.  In all other cases, the original proposition is contingent.</p>

<p>If the proposition contains modalities (possibility, necessity), the proposition can't simply be decided by evaluating it under every kind of world.  If this were done, it would have the effect of treating each <a href="#nullary_predicate">nullary predicate</a> as if it were a contingent proposition, and every kind of object as a contingent kind of object.  It would have the effect of making the software decide modalities in unexpected ways.  For instance, the software would decide that <span class="symbolic">[]P-&gt;~P</span> is necessarily true, since <span class="symbolic">P</span> here would be assumed always to be a contingent proposition, and therefore never necessarily true.  Instead, the software evaluates the proposition under every interpretation.  If it is true for every kind of world under every <a href="#interpretation">interpretation</a>, then the proposition is necessarily true.</p>


<h4 id="universal_generalization">Evaluation of a Universal Generalization</h4>

<p>The obvious way to <a href="#evaluate">evaluate</a> a universal generalization is to instantiate its variable with each object in the world and <a href="#evaluate">evaluate</a> each of the resulting propositions; if all instantiations are true, the generalization is true; if any are false, the generalization is false.  The problem with this approach is that a world may have an infinite number of objects in it, so evaluation in a finite amount of time may not be possible.  The software does not try to do this.  It takes a different, but similar approach.</p>

<p>Suppose all of the objects in a world can be grouped into a finite number of kinds.  Suppose further that these kinds are defined in such a way that, if a universal generalization is instantiated with any object of a kind, the resulting proposition is logically equivalent to the proposition that would result from an instantiation with any other object of the same kind.  If all that is true, then the universalization is <a href="#decide">decidable</a>.  And all that <em>is</em> true.  The logical elements supported by the software allow for possible worlds to be grouped this way (how this grouping is done is defined <a href="#kind_of_object">elsewhere</a>). To evaluate a universal generalization, the software instantiates the universal generalization with each <a href="#kind_of_object">kind of object</a> until all kinds of object have been tried or until one instantiation is found to be false.  If all instantiations are true, the universal generalization is true, if any instantiations are false, the universal generalization is false.</p>

<h4>Evaluation of a Conjunction (logical AND)</h4>

<p>To evaluate a conjunction, the software evaluates the conjoined propositions.  If both are true, the conjunction is true.  If either is false, the conjunction is false.</p>

<h4>Evaluation of a Disjunction (logical OR)</h4>

<p>To evaluate a disjunction, the software evaluates the disjoined propositions.  If both are false, the disjunction is false.  If either is true, the disjunction is true.</p>

<h4>Evaluation of a Negation (logical NOT)</h4>

<p>To evaluate a negation, the software evaluates the negated proposition.  If it is true, the negation is false.  If it is false, the negation is true.</p>

<h4 id="material_conditional">Evaluation of a Material Conditional</h4>

<p>To evaluate a material conditional, the software evaluates its antecedent and its consequent.  If the antecedent is true and the consequent is false, then the material conditional is false.  In all other cases, the material conditional is true.</p>

<h4>Evaluation of an Equivalence</h4>

<p>To evaluate an equivalence, the software evaluates both sides of the equivalence.  If they have the same truth value, the equivalence is true.  If they have different truth values, the equivalence is false.</p>

<h4>Evaluation of a Joint Denial</h4>

<p>To evaluate a joint denial, the software evaluates the denied propositions.  If they are both false, the joint denial is true.  If either are true, the joint denial is false.</p>

<h4>Evaluation of other Logical Elements</h4>

<p>The software <a href="#replacement">replaces</a> all other logical elements supported by the language with equivalent combinations of elements, and so does not need additional processes to evaluate them.</p>

<h4 id="evaluation_of_a_necessity">Evaluation of a Necessity</h4>

<p>Whether or not a proposition is necessarily true is determined by evaluating the proposition in each <a href="#kind_of_world">kind of world</a> that is possible under the current <a href="#interpretation">interpretation</a> of the predicates in the proposition.  If it is true for all such <a href="#kind_of_world">kinds of worlds</a>, then it is necessarily true.  If it is false under any such kind of world, then it is not necessarily true.  Proof: If the proposition is true in all <a href="#kind_of_world">kinds of worlds</a>, then it is true in all <a href="#possible_world">possible worlds</a>, and therefore necessarily true.  If the proposition is false in any <a href="#kind_of_world">kind of world</a>, then it is false in some <a href="#possible_world">possible world</a>, and therefore not necessarily true.</p>

<h4>Evaluation of a Predication on One Variable</h4>

<p>Whenever the software evaluates a <a href="#unary_predicate">unary predication</a>, it has already instantiated the predication's variable with one <a href="#kind_of_object">kind of object</a> or another.  Proof: Since the software rejects propositions with unbound variables, and defines all quantifications in terms of universal generalizations, if a proposition is being evaluated, all variables in that proposition are bound by universal generalizations.  Since the software proceeds from the top of the tree downward, a predication on a variable is only evaluated in order to evaluate the universal generalization further up the tree that binds that variable.  Because of the process of evaluating universal generalizations, that variable has always been instantiated by the software by the time the predication is evaluated.</p>

<p>The predication is true if the predicate is true of the instantiated <a href="#kind_of_object">kind of object</a>, and false if the predicate is not true that kind of object.</p>

<h4 id="nullary_predicate">Evaluation of a Predication on No Variables (a Nullary Predicate)</h4> 

<p>The <a href="#kind_of_world">kind of world</a> under which the software is currently evaluating the nullary predicate determines whether that nullary predicate is true or false.  Which kind of world it is depends on the nearest <a href="#evaluation_of_a_necessity">necessity</a> above the predication in the tree.  If there is no necessity above the predication, then the kind of world is chosen as a part of the overall <a href="#decision">decision</a> process.</p>

<h4>Evaluation of an Identification</h4>

<p>Whenever the software evaluates an identification, it has already instantiated each of the identification's variables with one <a href="#kind_of_object">kind of object</a> or another.  Proof: Since the software rejects propositions with unbound variables, and defines all quantifications in terms of universal generalizations, if a proposition is being evaluated, all variables in that proposition are bound by universal generalizations.  Since the software proceeds from the top of the tree downward, an identification of two variables is only evaluated in order to evaluate the universal generalizations further up the tree that bind those variables.  Because of the process of evaluating universal generalizations, those variables have always been instantiated by the software by the time the predication is evaluated.</p>

<p>The identification is true if its variables have been instantiated with the same kind of object, and false if they have been instantiated with two different kinds of object.  The software assumes that transworld identity of indiscernibles is impossible; it always considers two objects to be different kinds of objects if they are from two different kinds of worlds.  A proof that transworld identity of indiscernibles is impossible can be found <a href="http://mackwai.blogspot.com/2014/08/transworld-identity-of-indiscserables.html" target="_blank">here</a>.</p>

<h3>Definitions</h3>

<h4 id="evaluate">Evaluate</h4>

<p>When the software <em>evaluates</em> a proposition, it determines if it is true or false under the current <a href="#interpretation">interpretation</a>, <a href="#kind_of_world">kind of world</a>, and instantiation of variables.</p>

<h4 id="decide">Decide</h4>

<p>When the software <em>decides</em> a proposition, it determines if it is necessarily true (valid), contingent (satisfiable but not valid), or impossible (not satisfiable).</p>

<h4 id="modality">Modality</h4>

<p>A proposition governed by a modal operator.  The software supports the <a href="http://en.wikipedia.org/wiki/Alethic_modality">alethic modalities</a> of <a href="http://en.wikipedia.org/wiki/Logical_possibility">possibility</a> and necessity.</p>

<h4 id="unary_predicate">Unary Predicate</h4>

<p>A unary predicate is a predicate over one variable; the term "monadic predicate" is synonymous, but I've chosen to use the term "unary predicate" for three reasons:</p>

<ol>
  <li>In most programming languages, operators that have one operand (e.g. negation, bit inversion) are called "unary operators".</li>
  <li>In functional programming, especially in the language Haskell, "monadic" is a significant term, which relates to the <a href="http://en.wikipedia.org/wiki/Monad_%28category_theory%29">monads</a> of category theory and not to predicates on one variable.</li>
  <li>The words "unary" and "predicate" both have their roots in Latin.  The word "monadic" has its roots in Greek.  So calling it a "monadic predicate" mixes linguistic roots, but calling it a "unary predicate" does not.</li>
</ol>

<p>A Unary predicate is about the same thing as a property.  In this document, the two are used interchangeably, except that a unary predicate "is true of" an object or "is not true of" an boejct, whereas an object "has" or "does not have" a property.</p>

<p>It may be important to note that "predicate" and "predication" are two different things.  A <em>predicate</em> is a proposition, property, or relation; a <em>predication</em> is the application of a predicate to some number of variables.</p>

<h4>Nullary Predicate</h4>

<p>Nullary predicates are the same as the "propositions" in <a href="http://en.wikipedia.org/wiki/Propositional_calculus">propositional calculus</a>; they are simply true or false within a possible world.  They can be thought of as predicates over zero variables - predicates over nothing - or everything, depending on how you look at it.  Hence the term "nullary predicate".</p>

<h4>Proposition</h4>

<p>In this document, the word "proposition" is used three different ways, one to mean a <a href="#nullary_predicate">nullary predicate</a>, another to mean any idea that must be true or false, and another to mean a data structure <a href="#parsing">constructed by the software</a> that captures some of the logical content of the idea it is supposed to represent.</p>

<h4 id="possible_world">Possible World</h4>

<p>The term chosen by philosophers to denote any way the universe might be, or might have been, had it not been what it is.</p>

<h4 id="kind_of_world">Kinds of Worlds</h4>

<p>To decide a proposition or evaluate a <a href="#modality">modality</a>, all <a href="#possible_world">possible worlds</a> must be grouped into a finite number of kinds of worlds.  The following paragraphs describes how this is done.</p>

<p>A nullary predicate is either true or false in a possible world.  A first-order proposition has only a finite number of nullary predicates in it, so with respect to the nullary predicates in a proposition, possible worlds can be grouped into kinds based on which of these nullary predicates are true within a world and which are false.  For a proposition which contains nullary predicates and no other kind of predicates, there are as many kinds of worlds as there are combinations of nullary predicates that can be selected from the nullary predicates in the proposition.  If a proposition contains <em>n</em> nullary predicates, then there are 2<sup><em>n</em></sup> kinds of worlds to evaluate.</p>

<p>Either a world has a certain kind of object in it or it doesn't.  If a proposition contains unary predicates and in-world identifications but no nullary predicates, the kinds of worlds it can distinguish are defined in terms of the <a href="#kind_of_object">kinds of objects</a> present or absent in a world.  If the software defines <em>n</em> kinds of objects for such a proposition, then it defines 2<sup><em>n</em></sup>-1 kinds of worlds for that proposition.  One is subtracted from the total number of combinations because the empty world is excluded from evaluation.  The software effectively assumes that there is no such thing as an empty world.  If it didn't, the software would decide that <span class="symbolic">x,Ax&amp;~Ax</span> is possible.  Maybe it should.</p>

<p>If a proposition contains nullary predicates and either unary predicates or in-world identifications, the software must define a kind of world for each combination of nullary predicates verified and combinations of kinds of objects present.  This is just the Cartesian product of the two, so there are up to 2<sup><em>n</em></sup>(2<sup><em>o</em></sup>-1) kinds of worlds that must be evaluated.</p>

<p>A proposition that contains modalities might involve <em>transworld identifications</em>, i.e. it might involve identifications whose subjects might belong to two different possible worlds.  For example, in &quot;<span class="symbolic">x,P&amp;&lt;&gt;(3y,y=x &amp; ~P)</span>&quot;, <span class="symbolic">y</span> is inside of a modality (<span class="symbolic">&lt;&gt;</span>) that <span class="symbolic">x</span> is outside of, and therefore <span class="symbolic">x</span> and <span class="symbolic">y</span> may belong to different possible worlds when <span class="symbolic">y=x</span> is evaluated. Because of this, the software must define multiple versions of each of the kinds of worlds mentioned in the preceding paragraph.  When there are <em>t</em> such transworld identifications, there are up to 2<sup><em>n</em></sup>(2<sup><em>o</em></sup>&nbsp;-&nbsp;1)&nbsp;&times;&nbsp;<em>t</em> kinds of worlds that must be evaluated.</p>

<h4 id="kind_of_object">Kinds of Objects</h4>

<p>To evaluate a <a href="#universal_generalization">universal generalization</a>, all objects in the world must be grouped into a finite number of <em>kinds of objects</em>.  The following paragraphs describes how this is done.</p>

<p>If a proposition contains no relations (e.g. identifications, binary predicates), and a finite number of properties, then it cannot distinguish between one object and another, if both of these objects have the same properties.  For example, <span class="symbolic">Xw-&gt;Tw</span> is false if <span class="symbolic">w</span> is instantiated with any of an umlimited number of objects that do not have the property <span class="symbolic">T</span> but have the property <span class="symbolic">X</span>, regardless of what other properties those objects might have.  So for such a proposition, objects can be grouped into kinds based on which of the proposition's unary predicates they verify and falsify.  There will be 2<sup><em>u</em></sup> of these kinds, one for each combination of unary predicates that may be chosen from <em>u</em> unary predicates.</p>

<p>If a proposition contains identifications, grouping objects by kinds is more complicated.
Two objects in a proposition may have the same properties that are mentioned in the proposition and yet not be identical, so defining kinds by properties alone is not enough.
For identifications, it is assumed that it is sufficient to evaluate each combination of 0 to <em>i</em> of each predicate combination, where <em>i</em> is the maximum number of distinct free variables involved in identifications for any matrix bound by a quantifier within the proposition.
I don't have proof for this assumption, but it seems to work.</p>

<p>Altogether, if there are <em>u</em> unary predicates in a proposition and <em>i</em> is the previously mentioned maximum, then up to <em>i</em>2<sup><em>u</em></sup> kinds of objects must be evaluated.</p>


<h4 id="interpretation">Interpretations</h4>

<p>When deciding a proposition that does not contain any <a href="#modality">modalities</a>, the software defines as many kinds of worlds as are possible under the assumptions that</p>

<ul>
  <li>All nullary predicates are contingent and do not necessarily have any logical relationship with each other.</li>
  <li>All combinations of properties are possible, e.g. <span class="symbolic">3x,Px&amp;Qx</span> is always possible, so <span class="symbolic">P</span> and <span class="symbolic">Q</span> cannot be interpreted as "awesome" and "not awesome", respectively.</li>
</ul>

<p>This works for propositions that do not contain modalities, but it will not work for propositions that contain modalities.  For propositions that contain modalities, the software must evaluate the proposition under these assumptions, but it must also evaluate the proposition under every other possible set of assumptions about the relationships of nullary predicates to each other and to the kinds of objects in a world.  The software does this by defining <em>interpretations</em>.  An <em>interpretation</em> is a set of <a href="#kind_of_world">kinds of worlds</a>; it contains every kind of world that is possible under a given interpretation of the predicates in the proposition, and no other kinds of worlds.  To evaluate a proposition under every possible interpretation, the software simply evaluates the proposition under every nonempty subset of the kinds of worlds that it defines for the proposition.  So, if there are <em>u</em> kinds of worlds for a proposition, then there are 2<sup><em>u</em>-1</sup> interpretations that must be evaluated.</p>


<h2>Notes</h2>

<h3>Semantics of Quantified Modal Logic</h3>

<h4>Transworld Identity</h4>

<p>It seems common in discussions of quantified modal logic to assume that two objects in two different possible worlds can be identical in some way; they are considered to be the same object.
In all quantified modal logics I have encountered, the equality operator ("<span class="symbolic">=</span>") means this kind of identity.
<!--As I have argued elsewhere, this identity or sameness cannot be an identity of indiscernibles.-->
I developed this software's handling of quantified modal logic without knowing that this kind of identity was what was normally used in quantified modal logics, and consequently made "<span class="symbolic">=</span>" indicate the one kind of identity that I knew was well-defined: identity of indiscernibles.
This makes the software's quantitified modal unusual, but I hope not useless.
It is possible to represent customary identity in the software's language.
Consider what it means for two objects in two different worlds to be the same object.
If I say "If I hadn't felt so sick on Monday, I would have gone to work", I'm talking about two possible worlds: the actual world and a counterfactual world where I went to work on Monday, but I am talking about one person who exists in both worlds.
But what is it that makes them the same?
My first guess would be that they share a property in common &mdash; that of being me &mdash; and they each is the only object in its respective world that has that property, but it isn't that simple.
In some other world, George Washington might not have been the first president of the United States of America.
If we started writing an alternative history about the USA as it would have been if George Washington had never been president, we would probably consider the non-presidental George Washington to be the same person as the actual George Washington, but we would not consider whomever else we chose to be the first president to be the same person as the actual first president of the USA, even thought they are the sole possessors of the property of being the first president of the USA in their respective worlds.
Why?
That's an interesting question, but for the immediate purposes of writing it as a symbolic statement, it doesn't need an answer.</p>

<p>To capture this notion of identity which is customarily used in modal logic in this language, we would choose a predicate to represent the property that the two objects are supposed to share in common, assert that no more than one object in a world can have that property, and then assert that both objects have that property.  For example:</p>

<pre class="symbolic">// In any world, there can only be one first president of the USA.
[]x,y, Px&Py -> x=y

// George Washington was the first president of the USA.
x,Gx -> Px

// George Washington might not have been the first president of the USA.
<>3x,Gx&~Px
</pre>

<p>Unfortunately, the software does not support statements of this complexity, so it can't decide statements that use this representation of transworld identity.</p>

<h4>Instantiation of Object inside of Modal Expressions</h4>

<p>Quantifiers are always evaluated within a Kind of World.  They only range over the objects which exist in that Kind of World. I'm not sure if I should call it "actualist", but the idea is at least similar to the idea in Rod Girle's <a href="http://www.amazon.com/Possible-Worlds-Rod-Girle/dp/0773526684"><em>Possible Worlds</em></a>.  So any time a variable is instantiated with a kind of object, the kind of world that it exists in is fixed.  This entails that "<span class="symbolic">x, Px -&gt; []Px</span>" is necessarily true.  If you wanted to express the proposition <em>if anything is P, then it is necessarily P</em>, you could use the formulation of transworld identity described above:</p>

<pre class="symbolic">// Choose R arbitrarily.
[]x,y, Rx&Ry -> x=y // In any world, there is no more than one R.

x, Rx & (Px -> []y, Ry -> Py)
</pre>

<p>Unfortunately, this expression involves too many interpretations and the software will reject it.</p>


<h3>Run-Time Efficiency and Limitations</h3>

<p>As can be seen by combining the formulas given in the sections on <a href="#kind_of_object">kinds of objects</a>, <a href="#kind_of_world">kinds of worlds</a>, and <a href="#interpretation">interpretations</a>, to decide a proposition with no modalities, the software must evaluate the proposition in up to <span style="font-size: medium;">2<sup><em>n</em></sup>&nbsp;&times;&nbsp;Max(0,&nbsp;2<sup><em>i</em>2<sup><em>u</em></sup></sup>&nbsp;-&nbsp;1)</span> kinds of worlds, where <em>n</em> is the number of distinct nullary predicates in the proposition, <em>u</em> is the number of distinct unary predicates in the proposition, and <em>i</em> is the maximum number of distinct free variables involved in identifications for any matrix bound by a quantifier within the proposition, or 1 if the proposition contains variables but no identifications, or 0 if the proposition contains no variables.  To decide a proposition with modalities, the software must evaluate the proposition in up to <span style="font-size: large;">2<sup>2<sup><em>n</em></sup>&nbsp;&times;&nbsp;Max(0,&nbsp;2<sup><em>i</em>2<sup><em>u</em></sup></sup>&nbsp;-&nbsp;1)</sup></span> interpretations.  This means that the algorithm does not scale well; its run time is exponential or super-exponential in relation to the complexity of the proposition being decided.  This does not, however, prevent the software from performing fast enough when deciding propositions with small values for <em>n</em>, <em>u</em> and <em>i</em>.</p>

<p>The software actually defines <em>i&#772;</em>2<sup><em>u</em></sup> kinds of objects, where <em>i&#772;</em> is <em>i</em> rounded up to the nearest power of 2.  It is not necessary for <em>i</em> to be rounded up in order for the algorithm to be correct, but it makes it easier to encode kinds of objects as binary numbers.  Also to keep binary encoding simple, it does define empty worlds, but it skips over them when evaluating propositions.  The software actually encodes kinds of worlds and interpretations as 32-bit binary numbers.  This enables the software to go fast, but does put a hard limit on the complexity of propositions it can decide; <span style="font-size: medium;"><em>n</em><em>&nbsp;+&nbsp;i&#772;</em>2<sup><em>u</em></sup>&nbsp;&le;&nbsp;32</span> for non-modal propositions and  <span style="font-size: medium;">2<sup><em>n</em>&nbsp;+&nbsp;<em>i&#772;</em>2<sup><em>u</em></sup></sup> &le; 32</span> for modal propositions.</p>

<p>The following tables list the largest combined values of <em>n</em>, <em>u</em> and <em>i</em> that the software supports.</p>

<table id="maxima_for_modal_propositions">
  <caption>Maxima for Modal Propositions</caption>
  <tr><td>5</td><td>0</td><td>0</td></tr>
  <tr><td>4</td><td>0</td><td>2</td></tr>
  <tr><td>3</td><td>1</td><td>2</td></tr>
  <tr><td>3</td><td>0</td><td>4</td></tr>
  <tr><td>2</td><td>0</td><td>8</td></tr>
  <tr><td>1</td><td>2</td><td>2</td></tr>
  <tr><td>1</td><td>1</td><td>4</td></tr>
  <tr><td>1</td><td>0</td><td>16</td></tr>
  <tr><td>0</td><td>0</td><td>17</td></tr>
</table>

<table id="maxima_for_non_modal_propositions">
  <caption>Maxima for Non-modal Propositions</caption>
  <tr><td>32</td><td>0</td><td>0</td></tr>
  <tr><td>31</td><td>0</td><td>2</td></tr>
  <tr><td>30</td><td>1</td><td>2</td></tr>
  <tr><td>30</td><td>0</td><td>4</td></tr>
  <tr><td>29</td><td>0</td><td>8</td></tr>
  <tr><td>28</td><td>2</td><td>2</td></tr>
  <tr><td>28</td><td>1</td><td>4</td></tr>
  <tr><td>28</td><td>0</td><td>16</td></tr>
  <tr><td>27</td><td>0</td><td>17</td></tr>
  <tr><td>26</td><td>1</td><td>8</td></tr>
  <tr><td>24</td><td>3</td><td>2</td></tr>
  <tr><td>24</td><td>2</td><td>4</td></tr>
  <tr><td>24</td><td>1</td><td>16</td></tr>
  <tr><td>22</td><td>1</td><td>17</td></tr>
  <tr><td>20</td><td>2</td><td>8</td></tr>
  <tr><td>16</td><td>4</td><td>2</td></tr>
  <tr><td>16</td><td>3</td><td>4</td></tr>
  <tr><td>16</td><td>2</td><td>16</td></tr>
  <tr><td>12</td><td>2</td><td>17</td></tr>
  <tr><td>8</td><td>3</td><td>8</td></tr>
  <tr><td>0</td><td>5</td><td>2</td></tr>
  <tr><td>0</td><td>4</td><td>4</td></tr>
  <tr><td>0</td><td>3</td><td>16</td></tr>
</table>

<h3>Contact</h3>

<p>You can contact me (the developer of this application) by emailing me at <span id="a"><span id="sgnimuc" class="backwards">g@sgnimuc.eiznekcam</span>mail.com</span> or by adding a comment to <a href="http://mackwai.blogspot.com/2014/11/feedback-for-somerbynetmacklogic.html" target="_blank">this blog post</a>.  I'm willing to answer questions or provide help on using the software.</p>

<p>You would be doing me a favor if you were to notify me of<p>

<ul>
  <li>bugs or errors in the software,</li>
  <li>incorrect decisions made by the software, or</li>
  <li>unclear or or incorrect statements in this document.</li>
</ul>

<p>Also,</p>

<ul>
  <li>If you find this application useful, I would like to know what you use it for.</li>
  <li>If there is any part of the user interface you find confusing, tell me and I'll try to improve it.</li>
  <li>If you have ideas for new features, feel free to suggest them.  I'm open to expanding this application's functionality, so long as it is in keeping with the Possible Worlds-based approach that the software is using to decide propositions.</li>
</ul>

<p id="feedback">Thanks.</p>

</div>

<script type="text/javascript">
function ReverseString(s)
{
    return s.split("").reverse().join("");
}
function sgnimuc()
{
  var sgnimuc = document.getElementById("sgnimuc");
  sgnimuc.className = sgnimuc.className.replace( /(?:^|\s)backwards(?!\S)/g , '' );
  sgnimuc.innerHTML = ReverseString(sgnimuc.innerHTML);
  var a = document.getElementById("a");
  if ( !(a.textContent === undefined) )
    a.innerHTML = "<a href=\"mailto:" + a.textContent + "\">" + a.innerHTML + "</a>";
}
</script>

</body>
</html>